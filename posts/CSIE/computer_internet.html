<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.73" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mister-hope.github.io/blog/posts/CSIE/computer_internet.html"><meta property="og:site_name" content="Yuan Heng's Blog"><meta property="og:title" content="計算機網路"><meta property="og:description" content="Info 三上修了計算機網路，但上了兩個星期覺得好像有點聽得懂又有點混亂，所以決定寫個筆記讀懂它。希望可以堅持寫完XD"><meta property="og:type" content="article"><meta property="og:image" content="https://hackmd.io/_uploads/HJTcbEvlJg.png"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2025-02-28T13:58:58.000Z"><meta property="article:tag" content="CSIE"><meta property="article:tag" content="Study Note"><meta property="article:published_time" content="2025-02-26T00:00:00.000Z"><meta property="article:modified_time" content="2025-02-28T13:58:58.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"計算機網路","image":["https://hackmd.io/_uploads/HJTcbEvlJg.png"],"datePublished":"2025-02-26T00:00:00.000Z","dateModified":"2025-02-28T13:58:58.000Z","author":[{"@type":"Person","name":"Yuan Heng","url":"https://albertwang1104.github.io/blog/"}]}</script><link rel="icon" href="/blog/favicon.png"><title>計算機網路 | Yuan Heng's Blog</title><meta name="description" content="Info 三上修了計算機網路，但上了兩個星期覺得好像有點聽得懂又有點混亂，所以決定寫個筆記讀懂它。希望可以堅持寫完XD">
    <link rel="preload" href="/blog/assets/style-BL5hG1VY.css" as="style"><link rel="stylesheet" href="/blog/assets/style-BL5hG1VY.css">
    <link rel="modulepreload" href="/blog/assets/app-DZYAv3Hw.js"><link rel="modulepreload" href="/blog/assets/computer_internet.html-8KyDC7ls.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/blog/assets/index.html-357t52A0.js" as="script"><link rel="prefetch" href="/blog/assets/intro.html-SNN8DbCp.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-gVli-4N_.js" as="script"><link rel="prefetch" href="/blog/assets/disable.html-CWCxiCxe.js" as="script"><link rel="prefetch" href="/blog/assets/encrypt.html-D-kk4GiC.js" as="script"><link rel="prefetch" href="/blog/assets/layout.html-BpC7wpaM.js" as="script"><link rel="prefetch" href="/blog/assets/markdown.html-8a7xgyF5.js" as="script"><link rel="prefetch" href="/blog/assets/page.html-Ctj8lnex.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BwZHmDMQ.js" as="script"><link rel="prefetch" href="/blog/assets/martingale convergence theorem.html-Bet8Ktq5.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BKQOqGIj.js" as="script"><link rel="prefetch" href="/blog/assets/graph.html-CFp-1NbN.js" as="script"><link rel="prefetch" href="/blog/assets/tree.html-DhvQu62a.js" as="script"><link rel="prefetch" href="/blog/assets/DDPM.html-SkFuvefW.js" as="script"><link rel="prefetch" href="/blog/assets/GAN.html-CmsmiwgH.js" as="script"><link rel="prefetch" href="/blog/assets/Neural Network.html-Wb6tAzhm.js" as="script"><link rel="prefetch" href="/blog/assets/U-Net.html-CM5EQPbD.js" as="script"><link rel="prefetch" href="/blog/assets/Chapter1 The Wave Function.html-DtTSRMIx.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-fJbkL9TE.js" as="script"><link rel="prefetch" href="/blog/assets/ARMA _ ARIMA Models.html-B473RRpS.js" as="script"><link rel="prefetch" href="/blog/assets/ANOVA.html-Bo_RdtXe.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-cA6oUOxV.js" as="script"><link rel="prefetch" href="/blog/assets/confidence_Interval.html-BN6io5OR.js" as="script"><link rel="prefetch" href="/blog/assets/dimension_reduction.html-BeQ8QqJ1.js" as="script"><link rel="prefetch" href="/blog/assets/estimation_of_parameters.html-Da6zC6_N.js" as="script"><link rel="prefetch" href="/blog/assets/hypothesis_testing.html-BhaZ5BX0.js" as="script"><link rel="prefetch" href="/blog/assets/large_sample_theory.html-B15zvsVu.js" as="script"><link rel="prefetch" href="/blog/assets/linear_regrassion.html-BvTDSWGb.js" as="script"><link rel="prefetch" href="/blog/assets/model_selection.html-CW4LZ8hl.js" as="script"><link rel="prefetch" href="/blog/assets/sampling _distribution.html-DBm_OwsC.js" as="script"><link rel="prefetch" href="/blog/assets/shrinkage_methods.html-CY5MeluB.js" as="script"><link rel="prefetch" href="/blog/assets/skewness.html-D3RdW54z.js" as="script"><link rel="prefetch" href="/blog/assets/statistical_test.html-CFstCS54.js" as="script"><link rel="prefetch" href="/blog/assets/2-1.html-BufQFyrk.js" as="script"><link rel="prefetch" href="/blog/assets/2-2.html-45M2acpT.js" as="script"><link rel="prefetch" href="/blog/assets/2-3.html-B_78Ad_p.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bpdjf1Zx.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-B33AlxF2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BLuAQEep.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CFwty9K7.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bt_VItzP.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-MU0xmjpk.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BKICRxvT.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bo-Dq0kF.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CcBveQF4.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DPmSd-VG.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Cq7oYWGt.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-6P-O0O9Z.js" as="script"><link rel="prefetch" href="/blog/assets/index.html--zklQRDj.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BcT6zMMp.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DPZ6OYst.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CYPMeclF.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DrpKWHcd.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-ILOabsa2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CrZ_QjJY.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DBr6E6pw.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CNb3N99m.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BsVTydfT.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-X5Oc6ncu.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BQdylj2V.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BlgYC7V-.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DCrIcsYK.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DBRZo3Jl.js" as="script"><link rel="prefetch" href="/blog/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/blog/assets/setupDevtools-QXEOFQJV-BaFexyqr.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/blog/" aria-label="Take me home"><img class="vp-nav-logo" src="/blog/favicon.png" alt><!----><span class="vp-site-name hide-in-pad">Yuan Heng&#39;s Blog</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/" aria-label="Home" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" height="1em" sizing="height"></iconify-icon><!--]-->Home<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/blog/posts/" aria-label="Posts" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="material-symbols:add-notes-outline" height="1em" sizing="height"></iconify-icon><!--]-->Posts<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/intro.html" aria-label="About Me" iconsizing="height"><!--[--><iconify-icon class="vp-icon" icon="material-symbols:family-star" height="1em" sizing="height"></iconify-icon><!--]-->About Me<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/albertwang1104/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/blog/" aria-label="Home" iconsizing="both"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" width="1em" height="1em" sizing="both"></iconify-icon><!--]-->Home<!----></a></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><iconify-icon class="vp-icon" icon="fa6-solid:book" width="1em" height="1em" sizing="both"></iconify-icon><span class="vp-sidebar-title">Posts</span><!----></p><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/blog/posts/martingale%20convergence%20theorem.html" aria-label="Martingale Convergence Theorem" iconsizing="both"><!---->Martingale Convergence Theorem<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">CSIE</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/blog/posts/CSIE/computer_internet.html" aria-label="計算機網路" iconsizing="both"><!---->計算機網路<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Data Structure and Algorithm</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Deep Learning</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Financial Math</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Quantum Mechanics</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Statistics</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/blog/intro.html" aria-label="About Me" iconsizing="both"><!--[--><iconify-icon class="vp-icon" icon="material-symbols:family-star" width="1em" height="1em" sizing="both"></iconify-icon><!--]-->About Me<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->計算機網路</h1><!----><hr></div><!----><!----><div class="theme-hope-content" vp-content><div class="hint-container info"><p class="hint-container-title">Info</p><p>三上修了計算機網路，但上了兩個星期覺得好像有點聽得懂又有點混亂，所以決定寫個筆記讀懂它。希望可以堅持寫完XD</p></div><!-- more --><h2 id="computer-networks-and-the-internet" tabindex="-1"><a class="header-anchor" href="#computer-networks-and-the-internet"><span>Computer Networks and the Internet</span></a></h2><p><strong>網際網路 Internet</strong> 是一個 <strong>「網路的網路」</strong>，由許多較小的<strong>網路 (network)</strong> ，像是家庭網路、企業網路和移動網路等組成一個大網路。這些網路透過不同的通訊技術（如光纖、無線電波、銅線）相互連結，並使用協定（protocols）的標準化規則來確保資料在網路之間能夠順利傳輸。</p><p><strong>協定（Protocol）</strong> 是指一組用來管理數位裝置之間如何交換資料的規則和標準。</p><blockquote><p>Protocols define the format, order of messages sent and received among network entities, and actions taken on message transmission, receipt.</p></blockquote><p>協定定義了網路實體之間發送和接收訊息的格式、順序以及訊息傳輸、接收所採取的操作。就像人類的語言一樣，我問了「今天天氣如何」，對方就會回答「今天是晴天」之類的，不會回答「我早上吃了一個蛋餅」，能有一個正常順暢、大家都能懂的溝通方式。</p><h2 id="網路架構" tabindex="-1"><a class="header-anchor" href="#網路架構"><span>網路架構</span></a></h2><p>網路架構由<strong>網路邊緣（Network Edge）</strong>、<strong>網路核心（Network Core）</strong>、<strong>網路接入（Access Networks）和實體媒介（Physical Media）</strong> 組成。</p><figure><img src="/blog/assets/1-Cz_U4UiV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="network-edge" tabindex="-1"><a class="header-anchor" href="#network-edge"><span>Network Edge</span></a></h3><p>Network Edge 故名思意就是網路的外圍部分，由終端設備（Hosts）組成，這些設備是用來生成和接收資料的，再通過各種網路技術來訪問 Network Core。Hosts可以分為兩種：</p><ol><li><strong>客戶端設備（Clients）</strong>：例如個人電腦、智慧手機、平板等，這些設備用來向伺服器發送請求。</li><li><strong>伺服器（Servers）</strong>：通常位於資料中心（Data Center），負責回應客戶端的請求，提供所需的資料或服務。</li></ol><h3 id="access-networks-and-physical-media" tabindex="-1"><a class="header-anchor" href="#access-networks-and-physical-media"><span>Access Networks and Physical Media</span></a></h3><p>Access Networks 是指 hosts 以什麼通訊方式連接到 network core。Access Networks 可以分為三種：</p><ol><li>住宅接入網路（Residential Access Networks）：家庭用戶通過這類接入網路連接到網路服務提供商（ISP）。</li><li>機構接入網路（Institutional Access Networks）：企業、學校等機構使用的接入網路，這類網路通常混合使用有線和無線技術。</li><li>移動接入網路（Mobile Access Networks）：移動設備如手機通過無線技術接入網路（如WiFi、4G/5G）。</li></ol><p>Access Networks 的主要技術有幾種：</p><ul><li>有線接入技術 <ul><li>電纜寬頻接入 (cable-based access)：通過混合光纖與同軸電纜（Hybrid Fiber Coax, HFC），下載速度可達 40 Mbps 至 1.2 Gbps，上傳速度 30-100 Mbps。</li><li>DSL (Digital Subscriber Line)：用家用電話線將資料連至網路。下載速度通常為 24-52 Mbps，上傳速度為 3.5-16 Mbps。</li></ul></li><li>無線接入技術 <ul><li>Wi-Fi</li><li>4G/5G 移動網路</li><li>藍牙（Bluetooth)</li><li>衛星網路</li></ul></li></ul><h3 id="network-core" tabindex="-1"><a class="header-anchor" href="#network-core"><span>Network Core</span></a></h3><p>Network Core 就是網路的「中樞」，負責在不同的 hosts 之間進行資料的傳遞和路由選擇。network core 的主要目的是傳輸資料 (Packet-switching)，通過多個相互連接的<strong>路由器 (router)</strong> 和 <strong>交換機 (switch)</strong>，將資料包從來源到目的地的傳輸過程。兩個Network Core的主要工作：</p><ul><li><strong>Routing</strong>: Routing 就是路由器 router 的工作，是一個 global 的操作。根據封包的 ip 位置，通過 routing algorithms 來決定資料包應該通過哪條路徑到達目標網路。</li><li><strong>Switching ( Forwarding )</strong> : Switching 是交換機 switch的工作，是一個 local 的操作，在同一個網路內，根據封包的目標MAC地址，將資料傳送到正確的裝置。</li></ul><p><strong>封包交換 Packet-switching</strong></p><ul><li>Store and Forward: 資料在傳輸時，整個封包必須全部傳到路由器，才能被傳送到下一個網路。所以在封包還沒全部傳到路由器前，先到的資料就會被存在路由器裡。在這個傳輸的過程所需要的時間就稱 packet transmission delay，one-hop transmission delay = L-bits \ R-bps<br><img src="/blog/assets/2-iep_yGYq.png" alt="" loading="lazy"></li><li>Queuing and Loss： 當資料到達的速度（位元/秒）超過傳輸速率時，封包就要排隊等待被轉發。如果排隊的封包太多，超過 router 的記憶體容量，封包就會 loss，無法傳到目的地。</li></ul><p><strong>電路交換 circuit switching</strong></p><p>封包交換的替代方案，就是<strong>電路交換 circuit switching</strong>，它的方法是在兩個端點之間預留專用的資源來建立連接，在傳輸的過程中，這些資源是專用的，並且不會與其他連接共享。電路交換有兩種：</p><ol><li>Frequency Division Multiplexing (FDM, 分頻多工): 根據頻率分割給不同的使用者通訊。<br><img src="/blog/assets/3-BTjo1J9H.png" alt="" loading="lazy"></li><li>Time Division Multiplexing (TDM，分時多工): 根據時間分割給不同的使用者通訊。<br><img src="/blog/assets/4-CkxEzxWp.png" alt="" loading="lazy"></li></ol><p><strong>Packet switching v.s circuit switching</strong></p><table><thead><tr><th>特性</th><th><strong>封包交換（Packet Switching）</strong></th><th><strong>電路交換（Circuit Switching）</strong></th></tr></thead><tbody><tr><td><strong>資源利用</strong></td><td>資源動態分配，可共享</td><td>資源專用，不共享</td></tr><tr><td><strong>路徑選擇</strong></td><td>動態選擇路徑，每個封包可走不同路徑</td><td>固定路徑，需在通訊前建立端到端路徑</td></tr><tr><td><strong>延遲與丟包</strong></td><td>可能有延遲，排隊時封包可能被丟棄</td><td>延遲低且無封包丟失</td></tr><tr><td><strong>資源利用效率</strong></td><td>利用率高，因為資源按需使用</td><td>利用率低，未使用的資源會閒置</td></tr><tr><td><strong>適用場景</strong></td><td>突發性資料流，如網頁請求、電子郵件</td><td>連續資料流，如語音通話、視頻會議</td></tr><tr><td><strong>應用</strong></td><td>網際網路、數據網路</td><td>傳統電話網路</td></tr></tbody></table><h2 id="網路性能" tabindex="-1"><a class="header-anchor" href="#網路性能"><span>網路性能</span></a></h2><p>網路性能（performance）的三個關鍵指標是：<strong>loss（資料丟失）</strong>、<strong>delay（延遲）</strong>、和<strong>throughput（吞吐量）</strong>。</p><ol><li><strong>Loss</strong> 是指在網路傳輸過程中，因為網路擁塞（queuing）會導致過多的封包，超出路由器或交換機的緩衝區極限，無法再存儲新的封包，封包會被丟棄，使得部分封包無法被傳送到目標。</li><li><strong>Delay</strong> 是指資料從來源設備傳送到目的地所花費的時間，也稱為<strong>total nodal delay</strong>，通常分為4種： <ul><li><strong>處理延遲（Processing Delay）</strong>：路由器或交換機處理每個封包所需的時間，包括檢查錯誤和決定封包傳輸路徑。</li><li><strong>排隊延遲（Processing Delay）</strong>：當封包到達路由器或交換機時，若已有其他封包在等待傳輸，封包將會在緩衝區中排隊，這導致了排隊延遲。排隊時間取決於網路的擁塞程度。</li><li><strong>傳輸延遲（Transmission Delay）</strong>：傳送封包到鏈路上所需的時間。Transmission Delay = file size (L，bytes) / transmission rate (R，bytes/s)</li><li><strong>傳播延遲（Propagation Delay）</strong>：封包在物理媒介上傳播的時間，取決於媒介的長度和訊號的傳播速度。較長的物理距離會導致較大的傳播延遲。Propagation Delay (s) = distence (m)/ propagation speed (m/s)</li></ul></li></ol><blockquote><p>total nodal delay = Processing Delay + Processing Delay + Transmission Delay + Propagation Delay</p></blockquote><ol start="3"><li><strong>Throughput</strong> 是指在特定時間內，從來源到目的地傳輸的資料量，通常以位元/秒（bps）為單位。可以分為<strong>瞬時吞吐量（Instantaneous Throughput）</strong> 和 <strong>平均吞吐量（Average Throughput）</strong>。影響吞吐量的因素如<strong>瓶頸鏈路（bottleneck link）</strong> ，封包傳輸路徑中最慢的鏈路決定了整個網路的吞吐量。如果某條鏈路的速率低於其他部分，整個資料流將被限制在這條鏈路的傳輸速率之內。<br><img src="/blog/assets/5-Nl24M9R-.png" alt="" loading="lazy"></li></ol><p>我們可以用<code>traceroute</code>指令去查看一個網域的路徑、延遲和資料丟失的情況。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>❯ traceroute ncueeclass.ncu.edu.tw</span></span>
<span class="line"><span>traceroute to ncueeclass.ncu.edu.tw (140.115.197.25), 64 hops max, 40 byte packets</span></span>
<span class="line"><span> 1  172.20.10.1 (172.20.10.1)  12.317 ms  3.992 ms  3.833 ms</span></span>
<span class="line"><span> 2  10.157.65.134 (10.157.65.134)  25.604 ms  179.198 ms  197.686 ms</span></span>
<span class="line"><span> 3  10.157.65.41 (10.157.65.41)  22.517 ms</span></span>
<span class="line"><span>    10.157.65.45 (10.157.65.45)  19.483 ms</span></span>
<span class="line"><span>    10.157.65.41 (10.157.65.41)  18.991 ms</span></span>
<span class="line"><span> 4  10.157.67.178 (10.157.67.178)  20.577 ms  17.749 ms  20.664 ms</span></span>
<span class="line"><span> 5  210-65-126-214.tylc-3336.hinet.net (210.65.126.214)  20.589 ms  19.209 ms  19.124 ms</span></span>
<span class="line"><span> 6  220-128-8-26.tyfo-3031.hinet.net (220.128.8.26)  19.845 ms</span></span>
<span class="line"><span>    220-128-9-190.tylc-3032.hinet.net (220.128.9.190)  23.144 ms</span></span>
<span class="line"><span>    220-128-8-22.tyfo-3031.hinet.net (220.128.8.22)  24.430 ms</span></span>
<span class="line"><span> 7  220-128-8-225.tyfo-3331.hinet.net (220.128.8.225)  22.901 ms</span></span>
<span class="line"><span>    220-128-8-141.tyfo-3331.hinet.net (220.128.8.141)  27.973 ms</span></span>
<span class="line"><span>    220-128-8-153.tyfo-3331.hinet.net (220.128.8.153)  23.176 ms</span></span>
<span class="line"><span> 8  211-22-39-249.tyfo-4901.hinet.net (211.22.39.249)  32.296 ms  20.075 ms  19.104 ms</span></span>
<span class="line"><span> 9  203-75-135-45.hinet-ip.hinet.net (203.75.135.45)  21.739 ms  1029.704 ms</span></span>
<span class="line"><span>    61-222-83-105.hinet-ip.hinet.net (61.222.83.105)  23.600 ms</span></span>
<span class="line"><span>10  203.72.244.142 (203.72.244.142)  20.711 ms</span></span>
<span class="line"><span>    coreswitch.ncu.edu.tw (203.72.244.236)  43.346 ms  20.975 ms</span></span>
<span class="line"><span>11  * * 203.72.244.186 (203.72.244.186)  46.478 ms</span></span>
<span class="line"><span>12  * * *</span></span>
<span class="line"><span>13  * * *</span></span>
<span class="line"><span>14  * * *</span></span>
<span class="line"><span>15  * * *</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="osi-and-tcp-ip" tabindex="-1"><a class="header-anchor" href="#osi-and-tcp-ip"><span>OSI and TCP/IP</span></a></h2><p>網路最早的參考模型是 OSI 七層協定，後來才開發出 TCP/IP 的四層協定。不過目前世界上還是多以 OSI 七層協定來定義網際網路的分層概念</p><p>OSI 七層協定從底層到上層分別是「實體層、資料鏈結層、網路層、傳輸層、會談層、表現層與應用層」：</p><figure><img src="/blog/assets/6-BRgpwlKf.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因為 OSI 七層協定規範的太嚴謹，後來美國軍方與柏克萊大學合作，開發了一個當時給學術單位使用的網路程式，後來被稱為 TCP/IP 協定，俗稱 Internet。</p><figure><img src="/blog/assets/7-8sUlKGek.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>分層的好處在於模組化，可以抽換程式碼，越接近硬體的階層為底層(layer 1)，越接近應用程式的則是高層(layer 7)。 不論是接收端還是發送端，每個一階層只認識對方的同一階層資料：</p><!-- <div align="center">
  <img src="https://hackmd.io/_uploads/BJOcIjGxJg.png" />
</div> --><figure><img src="/blog/assets/8-BuCJuRhJ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因此應用程式在傳封包時，封包經過每一個階層時便會附加該階層的資訊，依序一直放到第一層內變成很大一包，傳給對方後再從第一層開始慢慢拆開。</p><h3 id="五層網路協定模型-tcp-ip" tabindex="-1"><a class="header-anchor" href="#五層網路協定模型-tcp-ip"><span>五層網路協定模型 (TCP/IP)</span></a></h3><ol><li><strong>應用層（Application Layer）</strong>：提供應用程式之間的網路服務，支持應用層協定（如HTTP、SMTP、DNS等），這些協定定義了應用程式如何與網路進行互動。</li><li><strong>傳輸層（Transport Layer）</strong>：負責應用程式之間的<strong>數據傳輸</strong>，並確保資料的可靠性（如TCP）或快速傳輸（如UDP）。TCP（傳輸控制協定）提供可靠的資料傳輸和錯誤檢測，而UDP（用戶數據報協定）則提供較少的控制但具有更快的傳輸速度。</li><li><strong>網路層（Network Layer）</strong>：負責將資料從源設備路由到目的設備，根據目標IP地址來決定數據包的傳輸路徑。IP協定是網路層的核心協定，負責封包的路由選擇與轉發。</li><li><strong>資料鏈路層（Link Layer）</strong>：負責相鄰設備之間的數據傳輸，並控制物理網路上資料的發送與接收，還包括錯誤檢測與資料流控制。</li><li><strong>物理層（Physical Layer）</strong>：處理 bits 在物理媒介中的傳輸，涉及信號的編碼和物理傳輸介質（如銅線、光纖、無線電波等）。</li></ol><h2 id="application-layer" tabindex="-1"><a class="header-anchor" href="#application-layer"><span>Application Layer</span></a></h2><p>網路應用程式的基本原則與概念，涵蓋了應用層協議的設計及實施的關鍵方面。</p><ul><li>訊息的類型：定義訊息的交換類型，例如請求（request）、回應（response）。</li><li>訊息語法：訊息格式和欄位如何劃分，定義了訊息應包含哪些欄位。</li><li>訊息語義：欄位內資訊的意義，也就是欄位中的資料所代表的內容。</li><li>訊息傳輸規則：什麼時候及如何在應用程式之間發送和回應訊息的規則。</li></ul><p><strong>Client-Server Paradigm:</strong> Server通常是持續運行的主機，Client與伺服器進行通訊，彼此之間不直接通訊。例子包括HTTP、IMAP、FTP等。<br><strong>Peer-to-peer (P2P) Paradigm:</strong> 沒有固定的伺服器，節點之間直接通訊，彼此提供服務。這種架構具有自我擴展性，新的節點帶來新的服務能力和需求，但管理較為複雜，典型應用包括BitTorrent等。</p><!-- ![image](https://hackmd.io/_uploads/HJTcbEvlJg.png) --><figure><img src="/blog/assets/9-DpWky-v4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>應用程式對傳輸層服務的需求主要有以下幾個方面：</p><ul><li>數據完整性（Data Integrity）：有些應用程式（如檔案傳輸、網頁交易）需要100%可靠的數據傳輸。</li><li>時延需求（Timing Requirements）：某些應用（如網路電話、互動遊戲）需要低時延才能有效運作。</li><li>吞吐量（Throughput）：多媒體應用通常需要最低的吞吐量保證，而其他應用則較為彈性，能利用任意可用的帶寬。</li><li>安全性（Security）：應用程式可能需要加密和數據完整性驗證。</li></ul><p><strong>Internet applications, and transport protocols</strong></p><table><thead><tr><th>application</th><th>application protocol</th><th>transport protocol</th></tr></thead><tbody><tr><td>file transfer/download</td><td>FTP</td><td>TCP</td></tr><tr><td>e-mail</td><td>SMTP</td><td>TCP</td></tr><tr><td>Web documents</td><td>HTTP</td><td>TCP</td></tr><tr><td>streaming audio/video</td><td>SIP, RTP, or proprietary</td><td>TCP or UDP</td></tr><tr><td>Internet telephony</td><td>HTTP, DASH</td><td>TCP or UDP</td></tr><tr><td>interactive games</td><td>WOW, FPS (proprietary)</td><td>TCP</td></tr></tbody></table><h3 id="web-and-http" tabindex="-1"><a class="header-anchor" href="#web-and-http"><span>Web and HTTP</span></a></h3><p><strong>HTTP（Hypertext Transfer Protocol）</strong> 是網頁的應用層協議，用於瀏覽器與網頁伺服器之間的通訊，使用Client-Server model。客戶端是瀏覽器，發送HTTP request 並顯示收到的網頁內容；伺服器是網頁伺服器，接收請求並回應相應的內容。HTTP是無狀態的（Stateless Protocol），即伺服器不會記住之前客戶端的請求狀態。每個請求都是獨立的。</p><p>HTTP 連接 TCP 有兩種類型：</p><ol><li>非持久性HTTP（Non-Persistent HTTP）：<br> 每次請求/回應都需要建立一個單獨的TCP連接。一個連接只傳送一個物件，然後關閉，導致需要多次連接才能加載完整的網頁。使得有N個物件要轉送時需要n個RTT。</li><li>持久性HTTP（Persistent HTTP）：<br> 同一個TCP連接可以用來傳送多個物件，減少建立連接的開銷。瀏覽器能夠並行處理資源的請求，從而縮短RTT。</li></ol><h4 id="http-request-and-response-message-form" tabindex="-1"><a class="header-anchor" href="#http-request-and-response-message-form"><span>HTTP request and response message form</span></a></h4><figure><img src="/blog/assets/10-p5shmssl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="http-request-method" tabindex="-1"><a class="header-anchor" href="#http-request-method"><span>HTTP request method</span></a></h4><p>HTTP中定義了不同的請求方法(Request Method)。並且，HTTP其中的一個設計目標為</p><blockquote><p>分離「資源辨識 (resource identification) 」與「請求語意(request semantics) 」。其中的請求語意便是HTTP所定義的請求方法所要規範的部分。</p></blockquote><p>而請求方法的設計含意便是：由客戶端(client)發出請求的目的(purpose)與期望伺服器(server)所回傳的結果。它們中的每一個實現了不同的語義，但它們的一組常見特徵是共享的：例如，一個請求方法可以是安全（Safe）、冪等（Idempotent）或可緩存（Cacheable）的。</p><ol><li><code>GET</code> 方法請求指定資源的表示。使用 GET 的請求只應檢索數據。</li><li><code>HEAD</code> 方法要求與 GET 請求完全相同的回應，但不包括回應主體。</li><li><code>POST</code> 方法將實體提交給指定的資源，通常導致狀態的變化或伺服器上的副作用。</li><li><code>PUT</code> 方法用請求載荷替換目標資源的所有當前表示。</li><li><code>DELETE</code> 方法刪除指定的資源。</li><li><code>CONNECT</code> 方法與目標資源識別的伺服器建立隧道。</li><li><code>OPTIONS</code> 方法描述目標資源的通信選項。</li><li><code>TRACE</code> 方法在到目標資源的路徑上執行消息回送測試。</li><li><code>PATCH</code> 方法對資源應用部分修改。</li></ol><h4 id="http-response-status-codes" tabindex="-1"><a class="header-anchor" href="#http-response-status-codes"><span>HTTP response status codes</span></a></h4><ul><li>200 OK：請求成功，伺服器回應所需的資源。</li><li>301 Moved Permanently：資源已永久移動，新的位置在回應中指定。</li><li>400 Bad Request：請求格式錯誤，伺服器無法理解。</li><li>404 Not Found：請求的資源未找到。</li><li>505 HTTP Version Not Supported：伺服器不支持請求使用的HTTP版本。</li></ul><h4 id="cookies" tabindex="-1"><a class="header-anchor" href="#cookies"><span>Cookies</span></a></h4><p>Cookies 是用來在瀏覽器和伺服器之間維持狀態的文字檔案。由於HTTP協議是無狀態的，每次請求都是獨立的，伺服器無法記住用戶的之前請求。因此 Cookies 被用來在不同的請求之間保留狀態信息，追蹤、個人化和保存關於每個使用者會話（session）的資訊，就是瀏覽的行為。</p><p><strong>cookies 的四個組成部分：</strong></p><ol><li>HTTP response 的cookie header</li><li>下一個 HTTP request 中的cookie header</li><li>儲存在 host 的cookie文件，由使用者的瀏覽器管理</li><li>後端資料庫</li></ol><p><strong>cookies 的運作方式：</strong><br> 當 client 第一次訪問網站時，伺服器在 HTTP response 中給一個 <code>Set-Cookie</code> 標頭，發送給用戶瀏覽器。該 Cookie 包含一個唯一的ID（例如userID=12345）。瀏覽器將這個 Cookie 儲存在用戶瀏覽器上。當用戶再次訪問同一網站時，瀏覽器會在 HTTP request 中自動附帶該網站的Cookie，讓伺服器可以識別用戶。伺服器根據收到的Cookie來查看用戶的信息或數據，從而提供個性化的服務。</p><figure><img src="/blog/assets/11-DzHYhDdt.png" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="web-caches-proxy-server" tabindex="-1"><a class="header-anchor" href="#web-caches-proxy-server"><span>Web caches, Proxy Server</span></a></h4><p><strong>Web Cache（網頁快取）</strong> 是一種中介設備，位於用戶和原始伺服器之間，負責存儲常請求的網頁內容。當用戶請求已快取的內容時，Web Cache可以直接提供資源，而無需訪問原始伺服器。可以減少客戶端的請求延遲和減輕原始伺服器的負擔，提升整體網路效能。</p><p><strong>Proxy Server（代理伺服器）</strong> 是作為用戶端和伺服器之間的中介，扮演著Web Cache的角色。對用戶來說，代理伺服器就像一個伺服器，提供快取的內容；對原始伺服器來說，它像一個用戶端，請求並存儲所需的內容。Proxy Server的另一重要作用是提高網絡安全性和隱私性，通過屏蔽用戶的實際IP地址。</p><figure><img src="/blog/assets/12-D4AqbJiV.png" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="http-2-http-3" tabindex="-1"><a class="header-anchor" href="#http-2-http-3"><span>HTTP/2, HTTP/3</span></a></h4><p>HTTP/2 於 2015 年發布，主要是在提升多物件請求的性能，減少延遲，改善 HTTP 1.1 中無法有效處理大量並行請求的限制。</p><p>HTTP/2 的主要特性：</p><ul><li>多路複用：同一連接中可並行處理多個請求和回應，消除「隊頭阻塞」（head-of-line (HOL) blocking），避免小物件等待大物件完成傳輸。</li><li>數據分幀：HTTP/2將傳輸的數據分為多個幀，每個幀可包含不同請求的數據，實現交錯傳輸，使客戶端更快獲取到不同內容。</li><li>伺服器推送：伺服器可以主動向客戶端發送相關資源（如圖片、樣式表等），無需等待客戶端請求，減少回應時間。</li><li>優先級控制：客戶端可設定不同資源的優先級，伺服器依優先級順序回應，提升重要資源的載入速度。</li></ul><figure><img src="/blog/assets/13-1n_5ucqV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>HTTP/3 是基於UDP的協議，旨在解決TCP協議引起的延遲問題，並增加安全性和容錯性。</p><p>HTTP/3 的主要特性：</p><ul><li>QUIC ( Quick UDP Internet Connections ) 協議：HTTP/3基於QUIC協議，將多個物件傳輸放在單個UDP連接內，但每個請求獨立處理，避免TCP的「隊頭阻塞」問題。</li><li>更快的連接建立：相比於TCP的三次握手，QUIC僅需一次握手即可建立安全連接，縮短首次連接的延遲。</li><li>內建加密：QUIC協議內建TLS加密層，增加傳輸的安全性，無需額外協商。</li><li>容錯性強：QUIC的設計讓數據丟包不會影響整體連接，傳輸更加穩定，適用於高流量或不穩定網絡環境。</li></ul><h3 id="e-mail-smtp-imap" tabindex="-1"><a class="header-anchor" href="#e-mail-smtp-imap"><span>E-mail, SMTP, IMAP</span></a></h3><p>電子郵件系統的三個主要組成部分：</p><ol><li>用戶代理（User Agent, UA）：用來編寫、讀取、編輯郵件的軟件或應用程序，如Outlook或Gmail。它負責將郵件發送至郵件伺服器並從伺服器中接收郵件。</li><li>郵件伺服器（Mail Server）：用於存儲用戶的郵件。每個用戶在郵件伺服器上都有一個信箱，用來接收和保存傳入的郵件。郵件伺服器同時也保存將要發送的郵件。</li><li>簡單郵件傳輸協議（Simple Mail Transfer Protocol, SMTP）：這是一種應用層協議，負責郵件在郵件伺服器之間的傳輸。它使用TCP協議來保證數據的可靠傳送。</li></ol><figure><img src="/blog/assets/14-4vfaiYGr.png" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="運作方式" tabindex="-1"><a class="header-anchor" href="#運作方式"><span>運作方式：</span></a></h4><ol><li>Headshaking: 用戶端傳送「telnet 《mail_server》 25」與伺服器端連線。</li><li>伺服器端回傳220訊息。</li><li>用戶端傳送「Hello 《Client》」告訴伺服器端client是誰。</li><li>伺服器端回傳250訊息。</li><li>建立連線完成，以下傳送訊息： <ul><li>用戶端傳送「MAIL FROM:《E-Mail Address》」，告知來源。</li><li>伺服器回傳250代表OK，550代表錯誤。</li><li>用戶端傳送「RCPT TO:《E-Mail Address》」，告知目的地。</li><li>伺服器回傳250代表OK，550代表錯誤。</li><li>用戶端傳送「DATA」指令，告知接下來要傳送Header和Body了。</li><li>伺服器回傳一個 354 的訊息，並且提及以「(換行).(換行)」作為郵件內容的結尾。</li><li>用戶端傳送Header與Body內容，最後以「(換行).(換行)」為結尾。</li><li>伺服器回傳250代表寄信成功。</li></ul></li><li>用戶端傳送「QUIT」結束連線。</li></ol><h4 id="imap-郵件存取協議-internet-mail-access-protocol" tabindex="-1"><a class="header-anchor" href="#imap-郵件存取協議-internet-mail-access-protocol"><span>IMAP：郵件存取協議（Internet Mail Access Protocol）</span></a></h4><p>IMAP 是用來從郵件伺服器上檢索郵件的協議。與SMTP不同，IMAP主要用於讀取和管理存儲在伺服器上的郵件，而不是傳輸郵件。IMAP提供了保留郵件在伺服器上，可以在伺服器上創建和管理資料夾來組織郵件。</p><h4 id="mail-message-format" tabindex="-1"><a class="header-anchor" href="#mail-message-format"><span>Mail message format</span></a></h4><figure><img src="/blog/assets/15-ChF1Otum.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="the-domain-name-system-dns" tabindex="-1"><a class="header-anchor" href="#the-domain-name-system-dns"><span>The Domain Name System (DNS)</span></a></h3><p>DNS（Domain Name System） 是網際網路上用來將人類可讀的域名(hostname)轉換成電腦可理解的IP地址的系統。DNS採用 <strong>分佈式(distributed)</strong> 的方式來管理網路上的域名，避免單點失效和流量過載等問題。</p><h4 id="dns-階層架構" tabindex="-1"><a class="header-anchor" href="#dns-階層架構"><span>DNS 階層架構</span></a></h4><ol><li>根域名伺服器（Root DNS Servers）：位於DNS層次結構的頂端，負責指向頂級域名伺服器（如 <code>.com</code>、<code>.org</code> 等）。</li><li>頂級域名伺服器（Top-Level Domain Servers, TLDs）：負責管理各自頂級域的域名解析，如 <code>.com</code>、<code>.org</code>、<code>.edu</code>、國家域名如 <code>.cn</code>、<code>.uk</code>等。</li><li>權威域名伺服器（Authoritative DNS Servers）：由各個組織運營，提供域名和IP地址的最終解析，例如 <code>example.com</code> 的權威伺服器能夠提供<code> www.example.com</code>的IP地址。</li></ol><h4 id="dns查詢過程" tabindex="-1"><a class="header-anchor" href="#dns查詢過程"><span>DNS查詢過程</span></a></h4><ul><li>迭代查詢（Iterative Query）：DNS客戶端發送請求給本地DNS伺服器，本地伺服器若無法解析，會返回下一個應詢問的伺服器地址，直到獲得最終結果。</li><li>遞迴查詢（Recursive Query）：本地DNS伺服器代表客戶端進行完整的解析，自己詢問所有必要的DNS伺服器，然後將最終結果返回給客戶端。</li></ul><figure><img src="/blog/assets/16-BksQJG4Y.png" alt="" width="550" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>DNS緩存（Caching）</strong></p><p>DNS 伺服器會將解析結果緩存一段時間（TTL，Time To Live），之後如果有查詢同一個 ip 就不用再重新查詢，以提高查詢效率和減少伺服器負載。緩存的解析結果會在 IP 地址更改後失效。</p><h4 id="dns資源記錄-resource-records-rr" tabindex="-1"><a class="header-anchor" href="#dns資源記錄-resource-records-rr"><span>DNS資源記錄（Resource Records, RR）</span></a></h4><p>DNS 資源記錄 是DNS數據庫中存儲的記錄，用於域名和其他信息的映射。每個記錄的格式是 (name, value, type, ttl)，常見的記錄類型包括：</p><ul><li><code>type=A</code>：將域名對應到IP地址。<code>name</code>是域名，<code>value</code>是IP地址。</li><li><code>type=NS</code>：指定該域名的權威DNS伺服器。<code>name</code> is domain (如 <a href="http://foo.com" target="_blank" rel="noopener noreferrer">foo.com</a>)，<code>value</code>是權威DNS伺服器的域名。</li><li><code>type=CNAME</code>：將域名指向另一個別名域名。<code>name</code>是某些「規範」的別名，<code>value</code>是規範名稱。如<code>www.ibm.com</code> 其實是 <code>servereast.backup2.ibm.com</code>。</li><li><code>type=MX</code>：指定處理該域名郵件的郵件伺服器。</li></ul><h4 id="dns-protocol-messages" tabindex="-1"><a class="header-anchor" href="#dns-protocol-messages"><span>DNS protocol messages</span></a></h4><ul><li>Header <ul><li>identification：16 bits，用於查詢、回覆查詢，對於每一個 #</li><li>flags：query or reply, recursion desired or recursion available, reply is authoritative or not.</li></ul></li><li>Question：包含要查詢的域名和查詢類型。</li><li>Answer：包含響應的資源記錄，提供了查詢結果。</li><li>Authority：指出哪個伺服器是此查詢的權威伺服器。</li><li>Additional Information：可選的額外數據，如IP地址。</li></ul><figure><img src="/blog/assets/17-C1YwFTgs.png" alt="" height="400" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="video-streaming-and-content-distribution-networks-cdn" tabindex="-1"><a class="header-anchor" href="#video-streaming-and-content-distribution-networks-cdn"><span>video streaming and content distribution networks (CDN)</span></a></h3><p>隨著影音內容的流行，尤其是像Netflix、YouTube等平台，每天都有數以百萬的用戶同時訪問，而且不同用戶具有不同的設備和網絡頻寬，因此串流必須處理如此大量的影音傳輸，適應不同的頻寬和設備。所以需要設計<strong>分散式</strong>的架構和應用層的架構來解決這些問題。</p><p>影片是由一系列圖像（每秒24或30張）組成，數位圖像由像素陣列構成，每個像素由位元來表示，所以可以透過編碼來減少需要傳輸的資料大小。下面是編碼轉輸的方法：</p><ul><li><strong>空間壓縮</strong>（Spatial Coding）：壓縮每個畫面內的冗餘信息。例如，重複的像素顏色值可以用顏色和重複次數來代替。</li><li><strong>時間壓縮</strong>（Temporal Coding）：只傳送與前一個畫面不同的部分，而不是每一幀畫面都完整傳輸。</li><li><strong>固定比特率（constant bit rate，CBR）</strong>：每秒傳輸的比特數固定，不論畫面複雜度如何。</li><li><strong>可變比特率（variable bit rate，VBR）</strong>：根據畫面的複雜度動態調整比特率，複雜的畫面使用較高的比特率，簡單的畫面使用較低的比特率。</li></ul><h4 id="串流影音的類型" tabindex="-1"><a class="header-anchor" href="#串流影音的類型"><span>串流影音的類型</span></a></h4><ul><li><strong>串流儲存影片（Streaming Stored Video）</strong>：影音已經被預先錄製和編碼，存儲在伺服器上，用戶可以隨時訪問。例如，Netflix和YouTube的影片。這類型的串流會遇到幾個問題： <ul><li>連續播放限制：在客戶端播放視頻時，播放時間必須與原始時間一致。但由於網絡延遲不穩定，因此需要在客戶端設置緩衝區以保持連續播放的穩定性。</li><li>客戶端交互性：使用者可能需要暫停、快進、倒帶或跳至其他視頻片段，這對播放的穩定性提出更高要求。</li><li>封包的丟失與重傳</li></ul></li><li><strong>實時視頻串流（Live Streaming）</strong>：用戶實時觀看正在發生的事件（如體育比賽、新聞直播）。與預錄視頻不同，實時串流要求更低的延遲。</li></ul><h4 id="dash-動態自適應串流-dynamic-adaptive-streaming-over-http" tabindex="-1"><a class="header-anchor" href="#dash-動態自適應串流-dynamic-adaptive-streaming-over-http"><span>DASH 動態自適應串流（Dynamic Adaptive Streaming over HTTP）</span></a></h4><p>影音檔案被分割成多個區塊（chunks），每個塊可以以不同的比特率編碼和儲存在伺服器上，在各個 CDN 節點中存入複製的檔案，並提供不同區塊的 URL。客戶端會定期檢查頻寬，根據當前的網路頻寬動態選擇適合的編碼版本下載並播放，且一次請求下載一整個區塊存在client的buffer，以降低延遲和同步的問題，確保影片播放的流暢性。</p><blockquote><p><strong>Streaming video = encoding + DASH + playout buffering</strong></p></blockquote><h4 id="內容傳遞網絡-cdns" tabindex="-1"><a class="header-anchor" href="#內容傳遞網絡-cdns"><span>內容傳遞網絡（CDNs）</span></a></h4><p>內容傳遞網路（Content Delivery Network or Content Distribution Network）是分佈在多個地理位置的伺服器組成的網路，用來加速內容傳輸，尤其是大流量的視頻和多媒體文件。減少響應時間、降低網路負載，通過將內容放置在離用戶較近的伺服器上來達到更快的響應速度。</p><p><strong>CDN的兩種架構</strong></p><ol><li><strong>Enter Deep CDN</strong>：將CDN伺服器深入部署到多個接入網絡中，靠近用戶端以減少延遲。Akamai是一個典型的例子，擁有數十萬台伺服器遍布全球。</li><li><strong>Bring Home CDN</strong>：將較少數量的大型伺服器集群放置於接入網絡附近的互聯網交換點（POPs）。</li></ol><h4 id="ott-over-the-top-傳輸的挑戰" tabindex="-1"><a class="header-anchor" href="#ott-over-the-top-傳輸的挑戰"><span>OTT（Over-The-Top）傳輸的挑戰</span></a></h4><ul><li><strong>OTT 內容傳輸</strong>（Over-The-Top）：指通過互聯網直接向用戶傳輸媒體內容（如Netflix），而不依賴傳統的有線或衛星電視基礎設施。OTT傳輸面臨如何在擁擠的互聯網上保障高效、順暢內容傳輸的挑戰。</li><li><strong>CDN 優化策略</strong>：CDN不僅需要考慮將哪些內容放在什麼位置，還需考慮在不同網絡情況下，選擇從哪個伺服器、以什麼速率向用戶傳輸內容。</li></ul><h3 id="p2p-applications" tabindex="-1"><a class="header-anchor" href="#p2p-applications"><span>P2P applications</span></a></h3><p>Peer-to-peer (P2P) 與傳統的 Client-Server 架構不同，P2P架構不依賴於一個永遠在線的中央伺服器。任意節點之間可以直接進行通訊。而且 P2P 網路可以自我擴展，新的節點不僅能帶來更多服務需求，還能增加新的服務能力。P2P系統中的節點可以隨時上下線，可能動態更改IP地址，因此需要較為複雜的管理系統來跟蹤這些變化。</p><p><strong>BitTorrent：P2P file distribution</strong></p><blockquote><p>Torrent: group of peers exchanging chunks of a file</p></blockquote><p><small style="color:red;"></small></p><p>BitTorrent 是 P2P 文件共享的典型例子。BitTorrent 的主要元素：</p><ul><li>文件分塊（Chunks）：在BitTorrent中，文件被分成小塊（Chunks，通常為256KB），這使得用戶可以同時從多個來源下載不同的 chunks，以提高下載效率。</li><li>Tracker：追蹤伺服器（Tracker）負責追蹤參與下載和上傳該文件的用戶列表，並幫助新加入的用戶找到可以連接的節點（其他用戶）。</li><li>Tit-for-tat機制：為了防止用戶只下載不上傳，BitTorrent實行一種互惠機制，節點之間優先給予對方文件上傳速度更快的節點分享數據。</li></ul><p><strong>運作流程</strong></p><ul><li>加入與下載：當用戶加入一個torrent時，會先向Tracker請求當前活躍節點的列表，然後開始與這些節點交換文件塊。</li><li>選擇性下載（Rarest First）：BitTorrent中的下載機制傾向於優先請求網路上較少的 chunks，這樣可以確保稀有的 chunks 在網路上被更快傳播，防止文件丟失。</li><li>隨機優選（Optimistic Unchoking）：為了避免只與少數節點分享數據，BitTorrent會定期隨機選擇一些節點提供文件塊，即使這些節點未提供數據回饋。</li></ul><h3 id="socket-programming-with-udp-and-tcp" tabindex="-1"><a class="header-anchor" href="#socket-programming-with-udp-and-tcp"><span>socket programming with UDP and TCP</span></a></h3><h4 id="socket-的概念" tabindex="-1"><a class="header-anchor" href="#socket-的概念"><span>Socket 的概念</span></a></h4><ul><li><strong>Socket</strong> 是應用程式和網路之間的接口，允許應用程序透過網絡傳送數據。 <ul><li><strong>應用程式控制</strong>：開發者控制應用層和傳輸層之間的通信。</li><li><strong>操作系統控制</strong>：傳輸層及以下的網絡通信部分由操作系統管理。</li><li>Socket 可以理解為應用程序的門戶，數據進出網絡都是通過這個“門”完成的。</li></ul></li></ul><p><strong>兩種主要的Socket類型</strong></p><ul><li><strong>UDP Socket</strong>：適用於基於無連接、資料報的通信。</li><li><strong>TCP Socket</strong>：適用於可靠的、基於連接的流式數據傳輸。</li></ul><h4 id="udp-socket" tabindex="-1"><a class="header-anchor" href="#udp-socket"><span>UDP Socket</span></a></h4><p><strong>UDP的特點</strong></p><ul><li><strong>無連接（Connectionless）</strong>：UDP無需在發送數據前建立連接，也無需結束連接。數據報會被直接發送到接收方。</li><li><strong>不可靠傳輸</strong>：UDP不能保證數據是否會送達或按順序到達，數據可能丟失或重複。</li><li><strong>無流控與擁塞控制</strong>：UDP不提供流量控制和擁塞控制，因此更適合於實時應用，如視頻通話、遊戲等，這些應用能夠容忍一定的數據丟失。</li></ul><p><strong>UDP client-server programming</strong></p><ul><li><p><strong>UDP client</strong>：</p><ol><li>創建一個UDP socket。</li><li>構建並發送數據報，指定伺服器的 IP 和 port。</li><li>接收來自伺服器的回應（數據報）。</li><li>關閉socket。</li></ol><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">AF_INET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">SOCK_DGRAM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">sendto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(message.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), (serverName, serverPort))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">modifiedMessage, serverAddress </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">recvfrom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2048</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>UDP server</strong>：</p><ol><li>創建一個UDP socket，並綁定到指定的 port。</li><li>持續監聽並接收來自客戶端的數據報。</li><li>處理數據並將結果回傳給客戶端。</li><li>（可選）根據需要關閉 socket。</li></ol><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">serverSocket </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">AF_INET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">SOCK_DGRAM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, serverPort))</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> True</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    message, clientAddress </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">recvfrom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2048</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    modifiedMessage </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> message.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">decode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">upper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">sendto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(modifiedMessage.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), clientAddress)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="tcp-socket" tabindex="-1"><a class="header-anchor" href="#tcp-socket"><span>TCP Socket</span></a></h4><p><strong>TCP的特點</strong></p><ul><li><strong>連接導向（Connection-oriented）</strong>：TCP在傳輸數據之前需要建立一個連接，並且在數據傳輸完成後需要關閉連接。這保證了數據的可靠傳輸。</li><li><strong>可靠傳輸</strong>：TCP提供數據的確認機制，確保數據不會丟失、重複或亂序。TCP還包含流量控制和擁塞控制。</li><li><strong>字節流（Byte Stream）</strong>：TCP數據以連續的字節流形式發送，沒有數據邊界。</li></ul><p><strong>TCP client-server programming</strong></p><ul><li><p><strong>TCP client</strong>：</p><ol><li>創建一個TCP socket。</li><li>使用伺服器的IP地址和端口號建立TCP連接。</li><li>發送 request 到伺服器，並接收伺服器的回應。</li><li>關閉 socket，結束連接。</li></ol><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">AF_INET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">SOCK_STREAM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">connect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((serverName, serverPort))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sentence.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">modifiedSentence </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">recv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">clientSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>TCP server</strong>：</p><ol><li>創建一個TCP socket，並綁定到指定的 port。</li><li>開始監聽來自客戶端的連接請求。</li><li>接受客戶端的連接，並為每個連接創建一個新的套接字。</li><li>接收來自客戶端的數據，進行處理，並將結果回傳。</li><li>關閉該連接的socket。</li></ol><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> socket </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">serverSocket </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">AF_INET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">SOCK_STREAM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">bind</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, serverPort))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">listen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> True</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    connectionSocket, addr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> serverSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">accept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    sentence </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> connectionSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">recv</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">decode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    capitalizedSentence </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sentence.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">upper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    connectionSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">send</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(capitalizedSentence.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">encode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    connectionSocket.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="socket-socket-的關鍵概念" tabindex="-1"><a class="header-anchor" href="#socket-socket-的關鍵概念"><span>Socket socket 的關鍵概念</span></a></h4><ul><li><p><strong>超時處理（Timeout Handling）</strong>：在進行網絡通信時，可能會發生延遲或無法接收到數據，這時可設置套接字的超時時間。Python可以使用 <code>settimeout()</code> 方法來設置超時。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">s.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">settimeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 設定超時時間為30秒</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>異常處理</strong>：通過 <code>try-except</code> 結構來捕捉和處理網絡通信中的異常情況，如超時或連接失敗。</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 嘗試接收數據</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">except</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> timeout:</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 處理超時情況</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="transport-layer" tabindex="-1"><a class="header-anchor" href="#transport-layer"><span>Transport Layer</span></a></h2><p>傳輸層提供 application process 之間的邏輯通信，讓運行於不同 hosts 上的應用可以互相通信。傳輸層的發送端將應用層資料分解為較小的數據段(segments)，並傳遞給網路層；傳輸層的接收端會重新組裝接收到的數據段並上傳給應用層。傳輸層是負責 process 之間的通信，而網路層則提供主機之間的通信服務。</p><p>傳輸層的主要協議</p><ul><li><strong>TCP（Transmission Control Protocol）</strong>：是一種連接導向的可靠傳輸協議，負責順序傳遞、擁塞控制和流量控制等。</li><li><strong>UDP（User Datagram Protocol）</strong>：提供無連接的不可靠傳輸，數據傳輸無需確認，適合對時延敏感但可容忍丟包的應用，例如多媒體應用。</li></ul><h3 id="multiplexing-and-demultiplexing" tabindex="-1"><a class="header-anchor" href="#multiplexing-and-demultiplexing"><span>Multiplexing and demultiplexing</span></a></h3><p><strong>發送端的多路複用 (multiplexing)</strong>：傳輸層在數據段中加入header（如 source port 和 destination port），標示datagram 的來源應用，然後封裝成 segments。這樣即使多個應用同時運行，傳輸層也可以根據這些 port 為每個應用分配獨立的數據流。</p><p><strong>接收端的分解 (demultiplexing)</strong>：當傳輸層接收到 datagram 後，會根據 destination port 來判斷應將 datagram 傳遞給哪個應用進程。</p><figure><img src="/blog/assets/18-CT_u2dDQ.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="demultiplexing-of-udp-and-tcp" tabindex="-1"><a class="header-anchor" href="#demultiplexing-of-udp-and-tcp"><span>Demultiplexing of UDP and TCP</span></a></h4><ul><li>UDP (Connectionless demultiplexing)：無連接的分解方式僅依賴 dest port，應用程式可以使用同一個 socket 接收 datagram，datagram 可能會被重新排列，適合要求不高但快速傳輸的應用。</li><li>TCP (Connection-oriented demultiplexing)：需要依賴 source IP、source port、dest IP、dest port 進行可靠分解，不同的 IP 和 port 需要用不同的 socket，確保 datagram 的正確順序。</li></ul><figure><img src="/blog/assets/19-DjrMcfGD.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp"><span>UDP</span></a></h3><p>UDP 是一種輕量級的<strong>無連接</strong>（connectionless）傳輸層協議，不需要建立和維護連接狀態。提供最簡單的 best-effort 傳輸，不保證 datagram 的交付、順序和可靠性，因此數據可能會丟失或到達順序錯亂，如果檢查發現 datagram 已損壞， datagram 將被丟棄。由於 UDP 沒有擁塞控制機制，它可以以最大速率發送數據，適合對速度要求高且容錯性強的應用。</p><h4 id="udp-segment-header" tabindex="-1"><a class="header-anchor" href="#udp-segment-header"><span>UDP segment header</span></a></h4><figure><img src="/blog/assets/20-FB5DuQep.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="udp-checksum" tabindex="-1"><a class="header-anchor" href="#udp-checksum"><span>UDP checksum</span></a></h4><p><strong>發送端</strong></p><ul><li>將 UDP segment 的內容（包括 UDP header 和 IP）視為 16 位整數序列。</li><li>對 segment 的內容進行<strong>一補數</strong>求和得到 checksum。（進位時，進位多出的部份會截斷並加到原本的和，最後再取總和的or）</li><li>將 checksum 的值填入 UDP header 的 checksum 欄位。</li></ul><p><strong>接收端</strong></p><ul><li>重新計算接收到的 segment 的 checksum。</li><li>檢查計算出的 checksum 是否與 segment 中的 checksum 一樣。如果不相等，表示檢測到錯誤；如果相等，表示未檢測到錯誤。</li></ul><figure><img src="/blog/assets/21-DYJLMK_m.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="principles-of-reliable-data-transfer-rdt" tabindex="-1"><a class="header-anchor" href="#principles-of-reliable-data-transfer-rdt"><span>Principles of reliable data transfer (rdt)</span></a></h3><p>Complexity of reliable data transfer protocol will depend (strongly) on characteristics of unreliable channel (lose, corrupt, reorder data?)</p><figure><img src="/blog/assets/22-CuipfMQE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="協議的演進-rdt-協議系列" tabindex="-1"><a class="header-anchor" href="#協議的演進-rdt-協議系列"><span>協議的演進（RDT 協議系列）</span></a></h4><ul><li><strong>rdt1.0</strong>：假設通道完全可靠，無 bit error、loss of packets，無需錯誤檢測，直接傳輸數據。</li><li><strong>rdt2.0</strong>：假設通道有 bits error，使用 ACK 和 NAK 來確認數據的正確性。 <ul><li>acknowledgements (ACKs): receiver explicitly tells sender that packet received OK</li><li>negative acknowledgements (NAKs): receiver explicitly tells sender that packet had errors</li><li>使用 checksum 檢查封包是否有 bit error。</li><li>stop and wait：sender 傳送一個資料包，然後等待 reciever 的 response。</li><li>當 sender 收到 NAK 時會重傳。</li></ul></li><li><strong>rdt2.1</strong>：處理 ACK/NAK 損壞 (garbled、corrupted) 的情況。 <ul><li>如果ACK/NAK損壞了，傳送端會重新傳送封包。</li><li>傳送端會在每個封包加上 sequence number。</li><li>接受端會刪掉重複 (duplicate) 傳遞的封包。</li></ul></li><li><strong>rdt2.2</strong>：NAK-free protocol。 <ul><li>和 rdt2.1 的功能一樣，但只使用 ACK</li><li>接收者傳送 ACK 如果上一個 packet 是正確的。</li><li>如果 sender 重複收到 ACK 則視為 NAK，重傳封包。</li></ul></li><li><strong>rdt3.0</strong>：考慮通道有 bit error and loss of packet。 <ul><li>引入超時重傳機制。如果 sender 沒有在設定的時間內收到 ACK ，啟動重傳。</li><li>如果封包（或 ACK）只是延遲但沒有丟失，可以用封包的序號處理重複傳送的封包。</li></ul></li></ul><h4 id="pipelined-protocols" tabindex="-1"><a class="header-anchor" href="#pipelined-protocols"><span>Pipelined protocols</span></a></h4><p>rdt3.0 的效率、使用率(utilization)極差。<br><img src="/blog/assets/23-CtBQBw7M.png" alt="" loading="lazy"></p><p>為了提高性能，所以引入並行的Pipelined protocols，可以同時傳遞多個還沒有被確認的封包。</p><ul><li>range of sequence numbers must be increased</li><li>buffering at sender and/or receiver</li></ul><figure><img src="/blog/assets/24-4laa8Wdw.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在可靠數據傳輸中，<strong>Go-Back-N（GBN）</strong> 和 <strong>Selective Repeat（SR）</strong> 是兩種常用的流水線傳輸協議，用於提高傳輸效率並處理數據包的丟失或損壞問題。</p><h4 id="go-back-n-gbn" tabindex="-1"><a class="header-anchor" href="#go-back-n-gbn"><span>Go-Back-N (GBN)</span></a></h4><p><strong>工作原理</strong></p><ul><li>GBN 是一種基於窗口（windows）的協議，允許發送方在未收到 ACK 的情況下，連續發送多個封包。</li><li>如果某個封包丟失或損壞，接收方只會確認（ACK）最後正確接收的封包。</li><li>一旦發送方發現超時，它會重傳從問題封包開始的所有後續封包，即 <strong>“回退重傳”</strong>。</li></ul><p><strong>Sender</strong></p><ul><li>大小最多為N的window、允許連續的(consecutive)未被確認的封包。<br><img src="/blog/assets/25-DMQ5FogP.png" alt="" loading="lazy"></li><li>“comulative ACK” - ACK(n) ： 確認小於或等於序號 n 的所有封包。</li><li>timer 是記錄最早發送的封包回傳 ACK 的時間。</li><li>timeout(n) : 重傳 seq #n 封包和之後所有窗口內的封包。</li></ul><p><strong>Receiver</strong></p><ul><li>只使用ACK</li><li>只接受in-order seq#的封包，並傳送ACK</li><li>只需記住 <code>rcv_base</code></li><li>處理 out-of-order 的封包 <ul><li>刪除(不buffer)順序亂掉的封包 =&gt; receiver沒有暫存器</li><li>reACK packet with highest in-order seq#(回傳最後一個確認的ack)<br><img src="/blog/assets/26-C7r3V2Sh.png" alt="" loading="lazy"></li></ul></li></ul><p><strong>流程</strong></p><ol><li><strong>窗口大小</strong>：發送方維持一個固定大小 N 的發送窗口，最多允許窗口內的封包同時處於「已發送但未確認」狀態。</li><li><strong>封包傳輸</strong>：發送方依次傳輸窗口內的封包。接收方對每個封包進行檢查，對最後正確接收的封包發送累積 ACK（comulative ACK）。</li><li><strong>錯誤處理</strong>：如果發送方未在超時期限內收到 ACK，或接收到 NAK，則重傳對應封包及其後續所有封包。</li><li><strong>窗口移動</strong>：當接收方確認窗口內最早的封包，窗口向前滑動，允許新的封包進入窗口。</li></ol><figure><img src="/blog/assets/27-BHM1sMN2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="selective-repeat-sr" tabindex="-1"><a class="header-anchor" href="#selective-repeat-sr"><span>Selective Repeat (SR)</span></a></h4><p><strong>工作原理</strong></p><ul><li>SR 是 GBN 的優化版本，它允許接收方對每個封包單獨確認，而不是累積確認。</li><li>當某個封包丟失或損壞時，發送方只需重傳該封包，而不是重傳後續所有封包。</li></ul><p><strong>Sender</strong></p><ul><li>只重傳沒收到 ACK 的封包。</li><li>timer 是記錄還沒收到 ACK 的封包的時間。</li><li>window 是用來限制傳送出去的、未確認的封包數量。</li><li><code>rcv_base</code> 是根據還沒收到 ACK 且序號最小的封包。<br><img src="/blog/assets/28-D0XPVeka.png" alt="" loading="lazy"></li></ul><p><strong>Reciever</strong></p><ul><li>分別確認所有正確接收的封包。</li><li>暫存 out-of-order 的封包，等所有封包 in-order 後，最終依序傳送到上一層。</li></ul><p><strong>流程</strong></p><ol><li><strong>窗口大小</strong>：發送方和接收方都維持一個窗口，大小為 N，窗口內的封包可以是未確認狀態。窗口大小需滿足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">N \leq 2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，其中 k 是序列號的位數，以避免接收方誤判重複封包。</li><li><strong>封包傳輸</strong>：發送方依次傳輸窗口內的封包，接收方根據序列號對封包進行驗證和緩存。接收方對每個正確接收的封包立即發送 ACK。</li><li><strong>錯誤處理</strong>：如果某個封包丟失或損壞，接收方會忽略該封包並緩存後續正確接收的封包。發送方在超時後只重傳未被確認的封包。</li><li><strong>窗口移動</strong>：當窗口內的最早封包被確認後，窗口滑動並允許新的封包進入。</li></ol><figure><img src="/blog/assets/29-CUIYn4Js.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>Dilemma of Selective Repeat</strong><br> 當 ACK 被丟失時，接收方是有收到封包的，記錄的序號會繼續往後增加。但發送方會發生 timeout，需要重傳封包。這個情況使得接收方以為收到的新封包，但實際上卻是重複收到封包，並沒有收到對應序號的封包。</p><figure><img src="/blog/assets/30-BRBT3h_i.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="總結" tabindex="-1"><a class="header-anchor" href="#總結"><span>總結</span></a></h4><ul><li><strong>Go-Back-N</strong> 更適合於數據丟失較少的場景，實現簡單且易於管理。</li><li><strong>Selective Repeat</strong> 在高丟包率場景中表現更高效，因為它避免了不必要的數據重傳，但需要更多的計算資源和緩存空間。</li></ul><hr><h3 id="connection-oriented-transport-tcp" tabindex="-1"><a class="header-anchor" href="#connection-oriented-transport-tcp"><span>Connection-oriented transport: TCP</span></a></h3><h4 id="tcp-基本特性" tabindex="-1"><a class="header-anchor" href="#tcp-基本特性"><span>TCP 基本特性</span></a></h4><ul><li><strong>point-to-point</strong>: one sender, one receiver</li><li>reliable, in-order byte stream.（資料被視為連續的 byte stream，沒有 message boundaries。）</li><li><strong>Pipeline</strong>: TCP congestion and flow control set window size.</li><li><strong>Buffering</strong>: send &amp; receive buffers</li><li><strong>full duplex data</strong>: bi-directional data flow in same connection（在同一個連接上有雙向的資料傳輸）</li><li><strong>connection-oriented</strong>: handshacking initializes sender, receiver state before data exchange（需要經過三次交握建立連線）</li><li><strong>Flow controlled</strong>: sender will not overwhelm receiver.（發送方不會壓倒接收方，一直無限制地傳資料給接收方）</li></ul><h4 id="tcp-segment-structure" tabindex="-1"><a class="header-anchor" href="#tcp-segment-structure"><span>TCP segment structure</span></a></h4><p>TCP segment 包含以下關鍵字段：</p><ul><li><strong>源端口號與目的端口號</strong>：標識通信的應用進程。</li><li><strong>序列號與確認號</strong>：用於可靠性和有序性保障。</li><li><strong>窗口大小 <code>rwnd</code></strong>：用於流量控制。</li><li><strong>標誌位</strong>：如 SYN、ACK、FIN 等，用於控制連接。</li><li><strong>校驗和</strong>：檢測數據段中的錯誤。</li></ul><figure><img src="/blog/assets/31-BHEHta_7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="tcp-sequence-numbers-acks" tabindex="-1"><a class="header-anchor" href="#tcp-sequence-numbers-acks"><span>TCP sequence numbers, ACKs</span></a></h4><ul><li>sequence number of a segment is the sequence number of the first byte in the data field <ul><li>segment的sequence number是data內第一個byte的sequence number</li><li>另解 : 要傳出的segment&#39;s data裡第一個byte在byte stream裡的number</li></ul></li><li>ACK is the sequence number of the next byte of data that the host is waiting for <ul><li>ACK是host正在等待的下個data中第一個byte的sequence number</li><li>另解 : 下一個預期會從另一端收到的第一個byte的seq #</li></ul></li></ul><figure><img src="/blog/assets/32-yxhFIwiS.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="tcp-rtt-timeout" tabindex="-1"><a class="header-anchor" href="#tcp-rtt-timeout"><span>TCP RTT, timeout</span></a></h4><ul><li>Timeout 的值是大於 RTT 的一個值。 <ul><li>如果小於 timeout 的值，不需要重傳（premature timeout, unnecessary retransmission)</li><li>如果大於 timeout 的值，則進行重傳（too long : slow reaction to segment loss）</li></ul></li><li>how to estimate RTT? <ul><li>SampleRTT (測量傳遞到接收確認的時間，不包含重傳)</li><li>由於 SampleRTT 會有不同，所以需要做點平均讓他平滑</li></ul></li></ul><p>EstimatedRTT = (1- <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>)*EstimatedRTT + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>*SampleRTT</p><ul><li>指數加權移動平均（exponential weighted moving average, EWMA)</li><li>過去的 SampleRTT 的影響以指數速率減少影響。</li><li>建議值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> = 0.125。</li></ul><p><strong>設定 timeout interval</strong></p><ul><li>因為 SampleRTT 的變化很大，所以 EstimatedRTT 需要加一個安全邊界。 <ul><li>timeout interval = EstimatedRTT + 4 * DevRTT</li></ul></li><li>DevRTT is EWMA of SampleRTT deviation from EstimatedRTT. <ul><li>DevRTT = ( 1 - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> ) * DevRTT + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> * | SampleRTT - EstimatedRTT |</li><li>建議值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">\beta = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.25</span></span></span></span></li></ul></li></ul><h4 id="tcp-sender-and-receiver" tabindex="-1"><a class="header-anchor" href="#tcp-sender-and-receiver"><span>TCP Sender and Receiver</span></a></h4><p><strong>TCP Sender</strong></p><ol><li><strong>事件：應用程序接收到數據</strong><ul><li>創建帶有序列號 <code>seq #</code> 的 segment。</li><li><code>seq #</code> 是 segment 中第一個字節的 byte-stream number。</li><li>如果定時器尚未啟動，則啟動定時器。 <ul><li>定時器為最早未被確認 <code>unACKed</code> 的 segment。</li><li>定時器的過期時間間隔為 <code>TimeOutInterval</code>。</li></ul></li></ul></li><li><strong>事件：超時</strong><ul><li>重傳超時的 segment。</li><li>重啟定時器。</li></ul></li><li><strong>事件：收到 ACK</strong><ul><li>如果 ACK 確認了先前未被確認的 segment：更新已被確認的數據範圍。</li><li>如果仍有未被確認的 segment，重啟定時器。</li></ul></li></ol><figure><img src="/blog/assets/33-Dqjlo4T3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>TCP Receiver</strong></p><table><thead><tr><th><strong>接收方事件</strong></th><th><strong>TCP 接收方行為</strong></th></tr></thead><tbody><tr><td>收到期望的序列號的 in-order segments，且所有數據至此已被確認 ACK。</td><td><strong>延遲 ACK</strong>：等待最多 500 毫秒以接收下一個 segment。如果沒有下一段，則發送 ACK。</td></tr><tr><td>收到期望的序列號的 in-order segments，但另一段仍有待確認的 ACK。</td><td><strong>立即發送單個累積 ACK</strong>，確認兩個按序段的接收。</td></tr><tr><td>收到 out-of-order segments 且序列號高於期望，中間有丟失。</td><td><strong>立即發送重複 ACK</strong>，指出期望的下一個字節的序列號。</td></tr><tr><td>收到的 segments 有部分完整或重傳後完整</td><td><strong>立即發送 ACK</strong>，前提是該段從間隙的低端開始。</td></tr></tbody></table><h4 id="tcp-fast-retransmit" tabindex="-1"><a class="header-anchor" href="#tcp-fast-retransmit"><span>TCP fast retransmit</span></a></h4><p>當中間有封包遺失，receiver 會接受到不符合預期的封包，receiver 會發送重複的 ACK (原先預期的封包)。當 sender 收到3次重複的 ACK 時，不會等 timer 結束，還是直接重傳。</p><figure><img src="/blog/assets/34-DpWV7MTR.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="tcp-連接建立-三次握手" tabindex="-1"><a class="header-anchor" href="#tcp-連接建立-三次握手"><span>TCP 連接建立：三次握手</span></a></h4><p>TCP 通過三次握手來建立連接，確保雙方都準備就緒並能同步初始序列號。</p><ol><li>客戶端發送 <code>SYN</code> 段，指定初始序列號（<code>seq=x</code>）。</li><li>服務器響應 <code>SYN+ACK</code> 段，確認客戶端的序列號並指定自己的初始序列號（<code>seq=y</code>，<code>ack=x+1</code>）。</li><li>客戶端發送 <code>ACK</code> 段，確認服務器的序列號（<code>ack=y+1</code>），連接建立完成。</li></ol><h4 id="tcp-連接關閉-四次揮手" tabindex="-1"><a class="header-anchor" href="#tcp-連接關閉-四次揮手"><span>TCP 連接關閉：四次揮手</span></a></h4><p>TCP 通過四次揮手來關閉連接，確保所有數據都被安全地傳輸。</p><ol><li>發送方發送 <code>FIN</code> 段，請求關閉數據傳輸。</li><li>接收方響應 <code>ACK</code> 段，表示收到請求。</li><li>接收方發送 <code>FIN</code> 段，請求關閉連接。</li><li>發送方響應 <code>ACK</code> 段，連接完全關閉。</li></ol><hr><h3 id="tcp-flow-control" tabindex="-1"><a class="header-anchor" href="#tcp-flow-control"><span>TCP flow control</span></a></h3><p>TCP 流量控制動態的調整接收窗口 <code>rwnd</code>，限制發送數據的速率的，防止接收方緩衝區溢出。TCP 使用 <strong>滑動窗口協議（Sliding Window Protocol）</strong> 來實現流量控制。</p><p><strong>接收窗口（Receiver Window, rwnd）</strong>：由接收方動態廣播的值，表示接收方能接受的數據量（以字節計）。發送方利用 <code>rwnd</code> 限制傳輸的數據量，確保不超過接收方的緩衝容量。如果 <code>rwnd = 0</code>（接收方緩衝區滿），發送方會暫停發送數據。發送方定期發送小的探測數據包（窗口探測：Window Probe）來確認接收方何時能恢復數據接收。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>RcvWindow = RcvBuffer-[LastByteRcvd - LastByteRead]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="/blog/assets/35-B6qEdcvn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>與擁塞控制的區別</strong></p><ul><li><strong>流量控制</strong>：針對發送方與接收方之間的通信，確保數據量匹配接收方的能力。</li><li><strong>擁塞控制</strong>：針對整體網絡狀況，防止網絡過載。</li></ul><hr><h3 id="tcp-congestion-control" tabindex="-1"><a class="header-anchor" href="#tcp-congestion-control"><span>TCP congestion control</span></a></h3><h4 id="擁塞問題的來源" tabindex="-1"><a class="header-anchor" href="#擁塞問題的來源"><span>擁塞問題的來源</span></a></h4><ul><li>當太多來源（sources）同時以過快的速度傳輸大量數據時，網絡可能超出其處理能力，導致以下問題： <ul><li><strong>延遲增加</strong>：由於緩衝區過載，封包等待時間延長。</li><li><strong>封包丟失</strong>：路由器或交換機的緩衝區溢出，造成數據丟失。</li></ul></li></ul><h4 id="擁塞控制的兩種機制" tabindex="-1"><a class="header-anchor" href="#擁塞控制的兩種機制"><span>擁塞控制的兩種機制</span></a></h4><ol><li><strong>端到端擁塞控制 (End-to-End Congestion Control)</strong>： <ul><li>發送方根據網絡狀況的間接指標（如丟包率或延遲）推斷是否發生擁塞。</li><li><strong>TCP 的方法</strong>： <ul><li>偵測到封包丟失（超時或多次重複 ACK）時，降低傳輸速率。</li><li>利用擁塞窗口（<code>cwnd</code>）動態調整傳輸速率，實現增長與減少的平衡。</li></ul></li></ul></li><li><strong>網絡輔助擁塞控制 (Network-Assisted Congestion Control)</strong>： <ul><li>路由器或其他網絡設備檢測到擁塞時，將擁塞狀況的資訊嵌入傳輸中的封包。</li><li>發送端與接收端依據該資訊調整傳輸速率。</li><li><strong>典型實現</strong>： <ul><li>Explicit Congestion Notification (ECN)：利用特定位元標記擁塞，通知傳輸雙方。</li></ul></li></ul></li></ol><h4 id="tcp-congestion-control-1" tabindex="-1"><a class="header-anchor" href="#tcp-congestion-control-1"><span>TCP congestion control</span></a></h4><p><strong>發送窗口公式</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>發送窗口大小 = min(cwnd, 接收窗口 (rwnd))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>cwnd</code>：反映網絡狀態，隨著擁塞狀況調整。</li><li><code>rwnd</code>：接收方的流量控制參數。</li></ul><h4 id="擁塞控制的四個階段" tabindex="-1"><a class="header-anchor" href="#擁塞控制的四個階段"><span>擁塞控制的四個階段</span></a></h4><ol><li><strong>慢啟動 (Slow Start)</strong>：初始傳輸速率低，<code>cwnd</code> 設置為 1 MSS（最大段大小）。每次接收到 ACK，<code>cwnd</code> 指數增長（每輪次倍增 *2）。當 <code>cwnd</code> 超過<strong>慢啟動閾值 (ssthresh, slow start threshold)</strong> 時，進入擁塞避免階段。</li><li><strong>擁塞避免 (Congestion Avoidance)</strong>：<code>cwnd</code> 緩慢（線性）增長. 每個傳輸輪次（RTT），<code>cwnd</code> 增加約 1 MSS（線性增長）。此階段的目的是穩定利用網絡容量，同時避免擁塞。</li><li><strong>快速重傳 (Fast Retransmit)</strong>：當接收方連續發送三個重複的 ACK 時，發送方判定數據丟失。發送方立即重傳丟失的 segment，而不等待超時。</li><li><strong>快速恢復 (Fast Recovery)</strong>：當快速重傳後，發送方將 <code>cwnd</code> 減半（表示網絡擁塞減緩）。設定 <code>cwnd = ssthresh</code>，然後進入擁塞避免階段。</li></ol><figure><img src="/blog/assets/36-CgFQO_89.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="擁塞控制的策略" tabindex="-1"><a class="header-anchor" href="#擁塞控制的策略"><span>擁塞控制的策略</span></a></h4><ul><li><strong>加法增長/乘法減少 (Additive Increase/Multiplicative Decrease, AIMD)</strong>： <ul><li>每個 RTT 增加 <code>cwnd</code>（線性增長）。</li><li>在擁塞時，減少 <code>cwnd</code>（通常減半）。<br><img src="/blog/assets/37-C8fwfV32.png" alt="" loading="lazy"></li></ul></li><li><strong>擁塞窗口更新規則</strong>： <ul><li><strong>新數據成功傳輸</strong>：增大 <code>cwnd</code>。</li><li><strong>擁塞檢測</strong>：減少 <code>cwnd</code>。</li></ul></li></ul><h2 id="network-layer-data-plane" tabindex="-1"><a class="header-anchor" href="#network-layer-data-plane"><span>Network Layer: Data Plane</span></a></h2><p>Network Layer 的兩大工作</p><ul><li><strong>forwarding:</strong> move packets from a router’s input link to appropriate router output link</li><li><strong>routing:</strong> determine route taken by packets from source to destination</li></ul><h4 id="data-plane" tabindex="-1"><a class="header-anchor" href="#data-plane"><span>Data Plane</span></a></h4><ul><li><strong>Local, per-router function</strong>：負責將進入路由器輸入端口的封包轉發到輸出端口。</li><li><strong>Forwarding process</strong>：基於封包標頭資訊，決定封包的下一跳路徑。</li><li>作為網路層的<strong>核心功能</strong>，通常在硬體上執行以達到線速（line speed）。</li></ul><h4 id="control-plane" tabindex="-1"><a class="header-anchor" href="#control-plane"><span>Control Plane</span></a></h4><ul><li><strong>Network-wide logic</strong>：負責路由表或流表的建構。</li><li><strong>兩種實作方式</strong>： <ul><li>傳統路由演算法：每個routers互相收集彼此的資訊，每個routers在各自的利用routing algorithm來計算出local forwarding table。<br><img src="/blog/assets/38-B37gvNQb.png" alt="" loading="lazy"></li><li>software-defined networking (SDN)：藉由遠端的控制器來計算forwarding table, 並且安裝在每個router上。<br><img src="/blog/assets/39-BjJKbSIX.png" alt="" loading="lazy"></li></ul></li></ul><h4 id="network-layer-service-model" tabindex="-1"><a class="header-anchor" href="#network-layer-service-model"><span>Network-layer service model</span></a></h4><p>目前採用的是<strong>Best-Effort model</strong>，其特點是：</p><ul><li><strong>不提供以下保證</strong>： <ul><li>確保封包成功到達目的地。</li><li>確保封包按順序或在特定時間內交付。</li><li>確保端到端的最低頻寬。</li></ul></li><li><strong>優勢</strong>： <ul><li>機制簡單，因此網際網路得以廣泛部署。</li><li>透過充分的頻寬預留，可以支持即時應用（如語音、視訊）。</li><li>應用層的分布式架構（如CDN）進一步提升性能。</li></ul></li></ul><p>網路層服務模型的比較：</p><table><thead><tr><th><strong>服務模型</strong></th><th><strong>頻寬</strong></th><th><strong>丟包</strong></th><th><strong>順序</strong></th><th><strong>延遲</strong></th></tr></thead><tbody><tr><td>Best Effort</td><td>無保證</td><td>無保證</td><td>無保證</td><td>無保證</td></tr><tr><td>ATM (CBR)</td><td>固定速率</td><td>保證交付</td><td>保證順序</td><td>保證延遲</td></tr><tr><td>DiffServ</td><td>最低保證</td><td>可能丟包</td><td>視情況而定</td><td>視情況而定</td></tr></tbody></table><hr><h3 id="what-s-inside-a-router" tabindex="-1"><a class="header-anchor" href="#what-s-inside-a-router"><span>What’s Inside a Router</span></a></h3><figure><img src="/blog/assets/40-Bqnk0dWl.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_1-input-port-function" tabindex="-1"><a class="header-anchor" href="#_1-input-port-function"><span>1. Input Port Function</span></a></h4><p>Input Port Function 是將接收到的封包從網路接口導入到路由器內部並進行必要的處理，以便下一步轉發。</p><figure><img src="/blog/assets/41-gCHtHBkX.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>基本組成部分</strong></p><ol><li><strong>物理層接收：</strong> 處理來自物理媒介的比特級接收，例如從光纖或銅線中提取數據訊號。</li><li><strong>鏈路層協議處理：</strong> 負責處理鏈路層協議（例如以太網）的數據幀，包括去除鏈路層頭部，提取IP數據包。</li><li><strong>轉發與查表：</strong> 基於封包的目標地址，從輸入端口內存中的 forwarding table 進行查找，決定目標輸出端口。分為： <ul><li><strong>Destination-based Forwarding（基於目標地址的轉發）</strong>：僅根據目標IP地址進行匹配。</li><li><strong>Generalized Forwarding（廣義轉發）</strong>：根據多個標頭欄位（例如來源IP、目標IP、傳輸層端口等）進行匹配。</li></ul></li></ol><p><strong>Decentralize Switching</strong></p><ul><li>利用 header 去 forwarding table 尋找適合的 output port。</li><li>假如 datagrame 到達的速率大於 forwarding 到 switch fabric 的速率，就會發生 queueing。</li><li>destination-based forwarding : 根據 destination IP address 去 forward。</li><li>generalized forwarding : 根據 header 中其他的值去判斷如何 forward</li></ul><h4 id="_2-longest-prefix-matching" tabindex="-1"><a class="header-anchor" href="#_2-longest-prefix-matching"><span>2. Longest prefix matching</span></a></h4><p><strong>查表方式：</strong> 將封包的目標IP地址與路由表中的多個前綴進行匹配，選擇匹配前綴最長的那條路由。</p><p><strong>高效資料結構支持：</strong> 使用高效數據結構如<strong>前綴樹（Trie）</strong> 或 <strong>TCAM（Ternary Content Addressable Memory）</strong> 進行匹配。</p><ul><li><strong>TCAM</strong>：支持並行搜索，可以在單個時鐘週期內完成查找。常見於高性能路由器中，例如 Cisco Catalyst。</li></ul><p><strong>Example</strong></p><table><thead><tr><th><strong>目標地址</strong></th><th><strong>路由表條目</strong></th><th><strong>前綴長度</strong></th><th><strong>選擇的路徑</strong></th></tr></thead><tbody><tr><td>11001000 00010111 00010110 10100001</td><td>11001000 00010111 00010*</td><td>20</td><td><strong>忽略</strong></td></tr><tr><td></td><td>11001000 00010111 00011*</td><td>22</td><td><strong>忽略</strong></td></tr><tr><td></td><td>11001000 00010111 00011000*</td><td>24</td><td><strong>選擇此條目</strong></td></tr></tbody></table><h4 id="_3-switching-fabric" tabindex="-1"><a class="header-anchor" href="#_3-switching-fabric"><span>3. Switching Fabric</span></a></h4><ul><li>負責將封包從 input port 移至適當的 output port。</li><li><strong>交換速率（Switching Rate）</strong>：交換矩陣將封包從輸入端口傳輸到輸出端口的速度，通常以（輸入/輸出）的倍數表示。假設每個input port的傳輸速率是R，今天有N個input link，則理想的switching rate是N*R</li><li>三種主要交換架構： <ol><li><strong>記憶體交換</strong>：受限於記憶體頻寬，速度較慢。</li><li><strong>匯流排交換</strong>：受限於匯流排頻寬，但速度高於記憶體交換。</li><li><strong>交叉連接網路</strong>：支持多平面（multi-plane）並行處理，具備高容量。</li></ol></li></ul><p><strong>交換矩陣架構類型</strong><br><img src="/blog/assets/42-CnKo2QA6.png" alt="" loading="lazy"></p><ol><li><strong>記憶體交換（Switching via Memory）</strong><ul><li>由一般電腦來完成，先將送進來的封包複製到處理器的記憶體中，處理器找出適當的輸出埠，再複製到輸出埠的緩衝區。</li><li><strong>特點</strong>： <ul><li>僅限於低速路由器。</li><li>受記憶體頻寬和 system bus 的限制。</li></ul></li><li><strong>缺點</strong>：每個封包需要兩次內存操作（寫入和讀取），速度瓶頸明顯。</li><li><strong>例子</strong>：初代路由器使用此設計。</li></ul></li><li><strong>匯流排交換（Switching via a Bus）</strong><ul><li>不需要處理器的介入，input port會在封包加一個標籤，指定要傳送出去的output port，並由shared bus傳到每個output port，output port 判斷該標頭是不是指自己，是的就保留，不是則捨棄。同一時間只有一個封包可以跨過bus，所以封包交換速度會受限於匯流排速度。</li><li><strong>特點</strong>：比記憶體交換快，適合中速路由器。</li><li><strong>缺點</strong>： <ul><li>當多個端口同時請求匯流排時，會發生競爭。</li><li>匯流排頻寬限制了整體性能。</li></ul></li><li><strong>例子</strong>：Cisco 5600 系列交換矩陣的匯流排速度為 32Gbps。</li></ul></li><li><strong>交叉網路交換（Switching via Interconnection Network）</strong><ul><li>利用棋盤式交換結構(crossbar switch)，若有N個輸入埠、N個輸出埠，會由2N條匯流排(N條水平、N條垂直)形成此結構，而交換結構控制器可以決定那些是斷開或閉合，此結構便可以實現同一時間轉送多個封包的功能。</li><li><strong>特點</strong>： <ul><li>提供並行處理能力，可以同時支持多個輸入和輸出端口的轉發。</li><li>每個封包可以分片（fragmentation）進入多條並行的數據路徑，並在輸出端口重組。</li></ul></li><li><strong>優點</strong>：適合高吞吐量要求的高速路由器。</li><li><strong>應用</strong>：Cisco CRS（Carrier Routing System）路由器，支持數百Tbps的交換容量。</li></ul></li></ol><h4 id="_4-input-port-queuing" tabindex="-1"><a class="header-anchor" href="#_4-input-port-queuing"><span>4. Input Port Queuing</span></a></h4><ul><li>當switch fabric的速度比input port傳入的速度慢，input port就會發生queuing 甚至是 loss。</li><li><strong>Head-of-Line (HOL) Blocking</strong>：前排的封包因目標端口被阻塞而無法轉發，導致後續封包也被延遲。例如，在多個封包爭奪同一目標端口時，僅最前方的封包會被嘗試轉發，其餘封包需等待。</li></ul><h4 id="_5-output-port-queuing" tabindex="-1"><a class="header-anchor" href="#_5-output-port-queuing"><span>5. Output Port Queuing</span></a></h4><p>當今天 datagram 到達 output port 的速率大於 output link 的 transmission rate，則會需要先將 datagram buffer 起來。(buffering when arrival rate via switch exceeds output line speed)</p><ul><li>Scheduling discipline : 選擇正在queueing的datagram進行傳送(擁有優先權的人可以享受到更好的效能)。</li><li>queueing (delay) and loss due to output port buffer overflow!</li></ul><h4 id="_6-buffer-management" tabindex="-1"><a class="header-anchor" href="#_6-buffer-management"><span>6. Buffer Management</span></a></h4><p>緩衝區管理負責決定緩衝區的使用和處理，包括新增封包、刪除封包以及擁塞控制。</p><ol><li><p><strong>封包丟棄 (drop) 策略</strong></p><ul><li><strong>尾丟棄（Tail Drop）</strong>：當緩衝區滿時，直接丟棄新到達的封包。方法簡單但可能導致全局性的TCP流量崩潰（全體TCP流因丟包同時進行擁塞控制）。</li><li><strong>優先級丟棄</strong>：當緩衝區滿時，根據封包的優先級決定丟棄哪個封包。</li></ul></li><li><p><strong>擁塞標記（Marking）</strong>：router 可以將 congestion 的訊號標記在 packet，讓 host 知道 (ECN、RED)。</p><ul><li><strong>早期擁塞檢測（Random Early Detection, RED）</strong>：在緩衝區接近滿時，隨機丟棄一些封包，讓發送端提前感知到擁塞，減少進一步擁塞風險。</li><li><strong>顯式擁塞通知（Explicit Congestion Notification, ECN）</strong>：不丟棄封包，而是在封包標頭中標記擁塞狀態，通知接收端進行調整。</li></ul></li></ol><p><strong>緩衝區大小設計</strong></p><ul><li>根據 RFC 3439 的建議，緩衝區大小應為：<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>緩衝區大小</mtext><mo>=</mo><mtext>典型往返時間 (RTT)</mtext><mo>×</mo><mtext>鏈路容量 (C)</mtext></mrow><annotation encoding="application/x-tex">\text{緩衝區大小} = \text{典型往返時間 (RTT)} \times \text{鏈路容量 (C)} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">緩衝區大小</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">典型往返時間</span><span class="mord"> (RTT)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">鏈路容量</span><span class="mord"> (C)</span></span></span></span></span></span></p><strong>例子</strong>： 對於10Gbps鏈路，假設RTT為250ms，緩衝區應為2.5Gb。</li><li><strong>緩衝過大問題</strong>：過大的緩衝區會導致延遲增加，特別是對即時應用（如視訊通話）造成不良影響。</li></ul><h4 id="_7-packet-scheduling" tabindex="-1"><a class="header-anchor" href="#_7-packet-scheduling"><span>7. Packet Scheduling</span></a></h4><p>封包排程是決定輸出端口中哪個封包優先被傳輸的一種機制。合理分配帶寬資源，確保服務質量（QoS）並優化網路性能。根據不同需求（公平性、優先級等）選擇合適的算法。</p><ol><li><p><strong>先到先服務（First Come, First Served, FCFS）</strong></p><ul><li>封包按照到達順序依次發送。</li><li>簡單但可能導致高優先級封包延遲。</li></ul></li><li><p><strong>優先級排程（Priority Scheduling）</strong></p><ul><li>進入 buffer(queue) 時根據 header 裡的資訊分類，會優先傳送優先權高的封包。如果兩個封包來自同一個優先權分類，則用FCFS決定誰先傳</li><li>如果低優先級封包數量大，可能導致「飢餓問題」（低優先級封包長時間無法被傳輸）。</li></ul></li><li><p><strong>輪巡排程（Round Robin, RR）</strong></p><ul><li>將不同類別的封包分配到多個隊列，按循環順序依次從每個隊列取出封包進行發送。</li><li>進入 buffer(queue) 時根據 header 裡的資訊分類，按循環順序依次從每個分類取出封包進行發送。<br><img src="/blog/assets/43-BH2N8C0_.png" alt="" loading="lazy"></li></ul></li><li><p><strong>加權公平佇列（Weighted Fair Queuing, WFQ）</strong></p><ul><li>原理跟 round robin 很像，一樣都會輪流傳送每一個類別的封包。但差別在於每個class都有自己的權重，會根據每個class的權重大小來決定這個class被輪到後一次可以傳送多少的封包，而不是像RR一樣，每次輪到每個分類都是傳一樣的份量。</li></ul></li></ol><h4 id="_8-network-neutrality" tabindex="-1"><a class="header-anchor" href="#_8-network-neutrality"><span>8. Network Neutrality</span></a></h4><p>保護所有的網路使用者都能不受限制的友善且合法的發言、創造與競爭。</p><ul><li>no blocking : 不要去阻擋合法友善的內容、應用程式或是服務</li><li>no throttling : 不能去損壞或是降級合法友善的網路傳輸</li><li>no paid prioritization : 不能去從事買賣網路優先權</li></ul><hr><h3 id="ip-the-internet-protocol" tabindex="-1"><a class="header-anchor" href="#ip-the-internet-protocol"><span>IP: The Internet Protocol</span></a></h3><p>IP（Internet Protocol）是網路層的核心協議，負責在網際網路上進行數據傳輸。</p><ul><li><strong>主要功能</strong>： <ol><li>封包的<strong>路由 (routing)</strong> 和<strong>轉發 (forwarding)</strong>。</li><li>提供統一的地址標識系統（IP address）。</li><li>支持資料的分片與重組。</li></ol></li><li><strong>特性</strong>： <ul><li><strong>無狀態（Stateless）</strong>：IP協議不會保留封包的狀態，適合可擴展的大規模網路。</li><li><strong>Best-Effort Service（盡力而為服務）</strong>：不保證數據的交付順序、可靠性和延遲。</li></ul></li></ul><figure><img src="/blog/assets/44-DvbWKKbO.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_1-ip-datagram-format" tabindex="-1"><a class="header-anchor" href="#_1-ip-datagram-format"><span>1. IP Datagram Format</span></a></h4><table><thead><tr><th><strong>欄位</strong></th><th><strong>說明</strong></th></tr></thead><tbody><tr><td><strong>版本號（Version）</strong></td><td>指定IP協議版本（IPv4 或 IPv6）。</td></tr><tr><td><strong>頭部長度（Header Length）</strong></td><td>IP頭部的長度，以 32-bit 字為單位（IPv4）。</td></tr><tr><td><strong>服務類型（Type of Service, ToS）</strong></td><td>指定服務的優先級和QoS需求（如延遲、吞吐量等）。</td></tr><tr><td><strong>總長度（Total Length）</strong></td><td>整個IP數據報的長度，包括頭部和數據部分。</td></tr><tr><td><strong>標識（Identifier）</strong></td><td>用於分片數據報的唯一標識。</td></tr><tr><td><strong>片偏移（Fragment Offset）</strong></td><td>指示分片在原始數據報中的位置。</td></tr><tr><td><strong>TTL（Time to Live）</strong></td><td>防止數據報無限循環，每經過一個路由器減1，減為0則丟棄。</td></tr><tr><td><strong>協議（Protocol）</strong></td><td>指定上層協議類型（例如TCP=6，UDP=17）。</td></tr><tr><td><strong>頭部校驗和（Header Checksum）</strong></td><td>用於驗證IP頭部數據的完整性。</td></tr><tr><td><strong>來源地址（Source Address）</strong></td><td>發送端的IP地址。</td></tr><tr><td><strong>目標地址（Destination Address）</strong></td><td>接收端的IP地址。</td></tr><tr><td><strong>選項（Options, 可選）</strong></td><td>用於擴展功能，如記錄路徑、時間戳等（IPv4 中較少使用）。</td></tr></tbody></table><figure><img src="/blog/assets/45-UwJob3gg.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="ip-addressing" tabindex="-1"><a class="header-anchor" href="#ip-addressing"><span>IP Addressing</span></a></h4><p>IP address 是用來識別 host 與 router interface 的 32-bits 識別碼。</p><p>interface 是 host 或 router 與 physical link 的連接點</p><ul><li>router 通常有多個interfaces</li><li>host 通常有一個或兩個 interfaces(乙太+無線網路)</li></ul><h4 id="subnet" tabindex="-1"><a class="header-anchor" href="#subnet"><span>Subnet</span></a></h4><p>裝置與裝置間的interface不需要經由中間路由器就能相連的裝置。</p><ul><li>subnet part : 在相同subnet的裝置，IP address有相同的high order bits</li><li>host part : 有自己獨有的low order bits</li><li>將router或host的interface分離，分離出的那塊孤立的區塊就是subnet</li></ul><ol><li><p><strong>IPv4 地址</strong></p><ul><li>32位地址，採用點分十進制格式（如192.168.1.1）。</li><li>包含<strong>子網部分</strong>和<strong>主機部分</strong>。</li><li><strong>子網劃分（Subnetting）</strong>： <ul><li>使用子網路遮罩（如 /24）劃分地址範圍。</li></ul></li><li><strong>CIDR（Classless Inter-Domain Routing）</strong>： <ul><li>address 中 subnet 部分的長度是隨意的</li><li>address format: <code>a.b.c.d/x</code>，x 是 subnet 部分的長度。<br><img src="/blog/assets/46-BawNVf7A.png" alt="" loading="lazy"></li></ul></li></ul></li><li><p><strong>IPv6 地址</strong></p><ul><li>128位地址，採用冒號分隔的十六進制格式（如2001:0db8::1）。</li><li>支持更大地址空間和更高效的路由。</li></ul></li></ol><h4 id="_2-dhcp-dynamic-host-configuration-protocol" tabindex="-1"><a class="header-anchor" href="#_2-dhcp-dynamic-host-configuration-protocol"><span>2. DHCP (Dynamic Host Configuration Protocol)</span></a></h4><p>DHCP 是應用層協議，用於動態分配 IP 地址和其他網路配置參數，實現設備**即插即用（Plug-and-Play）**的網路連接功能。</p><ul><li><strong>目標</strong>：自動為設備分配 IP 地址，並提供相關的網路參數（如子網掩碼、默認網關、DNS 服務器地址等）。</li><li>大部分 DHCP server 是被建置在 router 內，服務 router 所連接的子網路。</li><li><strong>優勢</strong>： <ul><li>減少手動配置錯誤。</li><li>支持地址重複利用，節省 IP 資源。</li><li>為移動設備提供靈活性。</li></ul></li></ul><p><strong>DHCP 的工作流程</strong></p><ol><li><strong>DHCP Discover（發現階段）</strong>：<strong>設備發送廣播消息</strong>尋找 DHCP 伺服器。</li></ol><ul><li>消息細節： <ul><li>源地址：<code>0.0.0.0</code>（設備尚未分配 IP）。</li><li>目標地址：<code>255.255.255.255</code>（廣播尋找所有伺服器）。</li><li><strong>作用</strong>：通知網路中有新設備需要 IP 地址。</li></ul></li></ul><ol start="2"><li><strong>DHCP Offer（提議階段）</strong>：<strong>DHCP 伺服器回應 Discover</strong> 請求，發送 DHCP Offer 消息。</li></ol><ul><li>消息是<strong>廣播形式</strong>，讓設備知道可用的 DHCP 配置。</li><li>提供： <ul><li>分配的 IP 地址。</li><li>子網掩碼、默認網關、DNS 等配置信息。</li><li>地址租約（Lease）的有效時間。</li></ul></li></ul><ol start="3"><li><strong>DHCP Request（請求階段）</strong>：<strong>設備選擇一個 DHCP Offer</strong>，回應 DHCP 伺服器以確認分配。</li></ol><ul><li>包含： <ul><li>請求的 IP 地址。</li><li>選擇的 DHCP 伺服器。</li></ul></li></ul><ol start="4"><li><strong>DHCP ACK（確認階段）</strong>：<strong>DHCP 伺服器最終確認分配</strong>，發送 DHCP ACK 消息。</li></ol><ul><li>設備正式使用分配的 IP 地址和其他配置。</li><li><strong>租約時間</strong>開始生效。</li></ul><figure><img src="/blog/assets/47-rGDd1xDV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/blog/assets/48-DZ74_TF_.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>DHCP message 的詳細結構</strong></p><ol><li><strong>交易 ID（Transaction ID）</strong>：用於識別特定的 DHCP 交互過程。</li><li><strong>客戶端 IP 地址（Client IP Address, ciaddr）</strong>：DHCP Discover 時為空，ACK 時填入分配的 IP。</li><li><strong>租約時間（Lease Time）</strong>：指定設備可以使用該 IP 地址的時間。</li><li><strong>選項字段（Options）</strong>： <ul><li>子網掩碼（Subnet Mask）。</li><li>路由器地址（Default Gateway）。</li><li>DNS 服務器地址（DNS Server）。</li></ul></li></ol><p><strong>DHCP 的特性</strong></p><ol><li><strong>地址租約（Lease）</strong>：DHCP 分配的 IP 地址有租約時間限制，租約過期後可以重新分配。設備可以在租約到期前請求續約（Renew）。</li><li><strong>地址重複利用</strong>：當設備離開網路或租約過期時，IP 地址可被其他設備重用，節省資源。</li><li><strong>支持移動設備</strong>：移動設備可以在不同網路中快速獲得新的 IP 配置。</li></ol><h4 id="_3-如何得到ip位址" tabindex="-1"><a class="header-anchor" href="#_3-如何得到ip位址"><span>3. 如何得到IP位址</span></a></h4><ol><li>取得固定IP位址，然後將host寫死</li><li>DHCP</li></ol><p><strong>Q:</strong> 網路如何得到subnet part of IP位址<br><strong>A:</strong> 向ISP租用ISP所擁有的IP位址。ISP會分配ISP所被分配到的address space(網段)給client，如今天有n個組織向ISP租用網路，ISP會將他被分配到的IP位址區塊進行切割，切割成n等分給這n個組織去使用。</p><p><strong>位址分配屬於階層式</strong></p><ul><li>route aggregation(聚合) : router可以設定條件 (如:<code>200.23.16.0/20</code>開時的傳給我)，讓封包透過階層式的傳遞，傳到正確的目的地。</li><li>而封包會選擇符合條件最多(最長)的router</li></ul><p><strong>那ISP如何取得網段</strong></p><ul><li>ICANN : Internet Coperation for assigned Names and Numbers</li><li>ICANN 會分配IP位址給5個regional registries(RRs)(區域網路註冊機構，是管理世界上某特定地區Internet資源的組織)</li><li>IPV4已經不夠用，但可以藉由NAT可以暫時解決IP位址不夠的問題。</li><li>而IPV6有128個bit，為未來將設法普及的定址方法，短時間內應該不會出現位址不夠分配的問題。</li></ul><h4 id="_4-nat-network-address-translation" tabindex="-1"><a class="header-anchor" href="#_4-nat-network-address-translation"><span>4. NAT (Network Address Translation)</span></a></h4><p>NAT 是通過在私有網路與公有網路間進行地址轉換來節省IPv4地址的技術。<br><img src="/blog/assets/49-Bl4mPgMr.png" alt="" loading="lazy"></p><ol><li><strong>功能</strong><ul><li><strong>地址共享</strong>：所有內部設備共享一個公共IP地址。</li><li><strong>安全性</strong>：內部網絡設備不直接暴露於外部網路。</li></ul></li><li><strong>工作流程</strong><ul><li><strong>出站封包</strong>：私有IP地址替換為公共IP地址，並分配新端口號。</li><li><strong>NAT translation table</strong>：router 會將 NAT IP address 與原本的 port number 跟其對應到的 source IP address 與新的 port number 存入 NAT translation table。</li><li><strong>入站封包</strong>：根據NAT表將公共IP地址映射回私有IP地址和端口號。</li></ul></li><li><strong>優點</strong><ul><li>只需要跟ISP租用一個IP，就能使私人區域網路能跟網際網路連線。</li><li>當區域網路內更改了其中一個host的IP位址，不需要告知外界。</li><li>如果換了另一家ISP的服務(換了IP)，也不用改變區域網路裡的IP位址。</li><li>可以讓外界無法直接地存取區域網路裡的裝置，對網路安全有幫助。</li></ul></li><li><strong>缺點</strong><ul><li><strong>破壞端到端連接</strong>：需要額外的NAT穿透技術。</li><li><strong>不符合IPv6的長期設計目標</strong>。</li></ul></li><li><strong>NAT的爭議</strong><ul><li>router &quot;應該&quot; 只處理網路層的功能</li><li>IP位址短缺問題應該由IPv6解決</li><li>違背end-to-end原則</li><li>client無法連接在NAT區域網路裡的server</li><li>之所以NAT還是一直被使用，是因為NAT已經廣泛應用在我們的家裡或是各個機構中</li></ul></li></ol><h4 id="_5-ipv6" tabindex="-1"><a class="header-anchor" href="#_5-ipv6"><span>5. IPv6</span></a></h4><p>IPv6 是為了解決 IPv4 地址耗盡問題而設計的新一代協議。<br><img src="/blog/assets/50-ydsPEEAW.png" alt="" loading="lazy"></p><ul><li>flow label : 同筆資料給予相同的label，可用來做流量控制及統計</li><li><strong>特性</strong><ul><li><strong>更大的地址空間</strong>：128位地址。</li><li><strong>固定長度頭部</strong>：簡化路由器處理。</li><li><strong>消除分片</strong>：要求端到端的MTU協商。</li><li><strong>內建的安全功能</strong>：支持IPSec。</li><li>可以讓其他網路層做流量處理。</li></ul></li><li><strong>過渡技術</strong><ul><li><strong>雙棧（Dual Stack）</strong>：同時支持IPv4和IPv6。</li><li><strong>隧道技術（Tunneling）</strong>：將IPv6的datagram放入IPv4 datagram裡的payload欄位中，在 IPv4 的routers中做傳遞。(封包放在封包內做傳遞)。廣泛用於4G/5G中，因為4G/5G是使用IPv6。<br><img src="/blog/assets/51-BDApTRIK.png" alt="" loading="lazy"></li></ul></li><li><strong>與IPv4的比較</strong><ul><li>由於沒有checksum，所以可以加速處理資料</li><li>no fragmentation/reassembly</li><li>no options</li></ul></li></ul><p><strong>Fragmentation and Reassembly</strong></p><p>當封包大於 link 的最大傳輸單元（MTU）時，需分片處理。</p><ul><li><strong>過程</strong>：路由器將數據包分片，並在 packet header 加上片偏移信息。目標設備負責將分片重組。</li><li><strong>IPv4 支持分片</strong>：中間路由器可分片。</li><li><strong>IPv6 消除分片</strong>：僅由發送端執行分片，提升中間路由器性能。</li></ul><hr><h3 id="generalized-forwarding" tabindex="-1"><a class="header-anchor" href="#generalized-forwarding"><span>Generalized Forwarding</span></a></h3><p><strong>Generalized Forwarding（廣義轉發）</strong> 是一種靈活的封包處理方式，通過匹配封包頭部的多個欄位並執行對應動作來實現封包的轉發、丟棄或修改。</p><ul><li>相較於傳統的<strong>基於目標地址的轉發</strong>，廣義轉發可以匹配更多欄位並執行更靈活的操作。</li><li><strong>核心思想</strong>：依賴轉發表（Forwarding Table）或流表（Flow Table）中的規則，基於「匹配 + 動作 (Match+Action) 」的抽象進行數據處理。</li></ul><h4 id="flow-table-abstraction" tabindex="-1"><a class="header-anchor" href="#flow-table-abstraction"><span>Flow table abstraction</span></a></h4><ul><li><strong>Flow</strong>: 可以是在 link layer, network layer, transport layer 裡 header 所定義的值。</li></ul><ol><li><strong>匹配（Match）</strong>：在封包的標頭中尋找特定欄位（例如 IP 地址、傳輸層端口號）與表項規則進行匹配。 <ul><li>支持多層協議欄位匹配： <ul><li><strong>link layer</strong>：源/目標 MAC 地址。</li><li><strong>network layer</strong>：源/目標 IP 地址。</li><li><strong>transport layer</strong>：TCP/UDP 源/目標端口號。</li></ul></li></ul></li><li><strong>動作（Action）</strong>：對匹配的封包執行指定操作 <ul><li><strong>轉發（Forward）</strong>：將封包發送至指定端口。</li><li><strong>丟棄（Drop）</strong>：阻止封包繼續傳輸。</li><li><strong>修改（Modify）</strong>：更改封包標頭內容，例如 NAT 中的地址重寫。</li><li><strong>發送至控制器（Send to Controller）</strong>：將封包交給遠端控制器進行進一步處理（SDN 中常見）。</li></ul></li><li><strong>優先級（Priority）</strong>：當多條規則匹配同一封包時，根據優先級選擇執行的動作。</li><li><strong>計數器（Counters）</strong>：計算匹配的封包和位元組數量，用於流量監控和診斷 (計算user的用量)。</li></ol><figure><img src="/blog/assets/52-C9UcNH5C.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><table><thead><tr><th><strong>匹配規則（Match Fields）</strong></th><th><strong>動作（Actions）</strong></th><th><strong>統計數據（Counters）</strong></th></tr></thead><tbody><tr><td><code>src=192.168.1.1</code></td><td>Forward(Port 1)</td><td>Packets=100, Bytes=5000</td></tr><tr><td><code>dst=10.0.0.1, TCP dport=80</code></td><td>Drop</td><td>Packets=50, Bytes=2500</td></tr><tr><td><code>src=10.0.0.*, dst=172.16.*</code></td><td>Modify TTL, Forward(2)</td><td>Packets=30, Bytes=2000</td></tr></tbody></table><p><strong>Match+Action 的示例</strong><br><strong>案例 1：阻擋特定 TCP 流量</strong></p><ul><li><strong>匹配條件</strong>：<code>dst=10.0.0.1, TCP dport=22</code>（SSH 流量）</li><li><strong>動作</strong>：<code>Drop</code></li><li><strong>解釋</strong>：防止外部設備使用 SSH 連接到內部伺服器。</li></ul><p><strong>案例 2：將 HTTP 流量轉發到特定端口</strong></p><ul><li><strong>匹配條件</strong>：<code>dst=192.168.1.1, TCP dport=80</code></li><li><strong>動作</strong>：<code>Forward(Port 2)</code></li><li><strong>解釋</strong>：將所有 HTTP 請求轉發到伺服器端口。</li></ul><p><strong>案例 3：修改 TTL 並記錄封包數量</strong></p><ul><li><strong>匹配條件</strong>：<code>src=10.0.0.*, dst=172.16.*</code></li><li><strong>動作</strong>：<code>Modify TTL=64, Forward(3)</code></li><li><strong>解釋</strong>：降低 TTL 並將封包轉發至端口 3，統計流量數據。</li></ul><p><strong>傳統轉發與廣義轉發的對比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>傳統轉發</strong></th><th><strong>廣義轉發</strong></th></tr></thead><tbody><tr><td><strong>匹配欄位</strong></td><td>僅基於目標 IP 地址</td><td>基於多層欄位（MAC, IP, TCP/UDP 等）</td></tr><tr><td><strong>動作</strong></td><td>僅支持轉發</td><td>支持轉發、丟棄、修改、記錄等多種操作</td></tr><tr><td><strong>應用場景</strong></td><td>靜態路由和目標地址匹配</td><td>SDN、網路安全、流量工程</td></tr></tbody></table><hr><h3 id="openflow" tabindex="-1"><a class="header-anchor" href="#openflow"><span>OpenFlow</span></a></h3><p>OpenFlow，一種位於data link layer的protocol，能夠控制switch或router的forwarding plane，藉此改變packets所走的網路路徑。</p><h4 id="openflow-的關鍵組件" tabindex="-1"><a class="header-anchor" href="#openflow-的關鍵組件"><span>OpenFlow 的關鍵組件</span></a></h4><ol><li><strong>OpenFlow 控制器</strong><ul><li>負責集中管理和控制網路中的 OpenFlow 交換機。</li><li>控制器安裝流表條目，定義網路流量的處理方式。</li><li>範例控制器：ONOS、OpenDaylight。</li></ul></li><li><strong>OpenFlow 交換機</strong><ul><li>負責執行控制器下發的流表規則。</li><li>包含以下關鍵模組： <ul><li><strong>流表（Flow Table）</strong>：儲存匹配規則和動作。</li><li><strong>封包緩存（Packet Buffer）</strong>：暫存未匹配的封包。</li><li><strong>通訊模組（OpenFlow Channel）</strong>：與控制器進行通信。</li></ul></li></ul></li><li><strong>OpenFlow 協議</strong><ul><li>定義控制器與交換機之間的通信格式和操作。</li><li>支持流表管理、封包處理和狀態查詢等功能。</li></ul></li></ol><figure><img src="/blog/assets/53-RRhdoAXF.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="flow-table-entry" tabindex="-1"><a class="header-anchor" href="#flow-table-entry"><span>Flow Table Entry</span></a></h4><table><thead><tr><th><strong>欄位</strong></th><th><strong>說明</strong></th></tr></thead><tbody><tr><td><strong>匹配欄位（Match Fields）</strong></td><td>定義封包標頭中用於匹配的欄位，如 IP、MAC、端口等。</td></tr><tr><td><strong>優先級（Priority）</strong></td><td>當多條規則匹配同一封包時，選擇優先級最高的規則。</td></tr><tr><td><strong>動作（Actions）</strong></td><td>指定封包的處理方式，如轉發到某端口、丟棄、修改標頭等。</td></tr><tr><td><strong>計數器（Counters）</strong></td><td>跟蹤匹配封包的數量和流量，用於流量統計與監控。</td></tr><tr><td><strong>超時（Timeouts）</strong></td><td>規則的有效時間，包括閒置超時（Idle Timeout）和硬性超時（Hard Timeout）。</td></tr><tr><td><strong>Cookie</strong></td><td>控制器設置的標識符，用於管理流表條目。</td></tr></tbody></table><h4 id="匹配欄位支持的層級" tabindex="-1"><a class="header-anchor" href="#匹配欄位支持的層級"><span>匹配欄位支持的層級</span></a></h4><p>OpenFlow 支持多層標頭欄位的匹配：</p><ol><li><strong>鏈路層</strong><ul><li>源 MAC 地址、目標 MAC 地址。</li><li>VLAN ID、EtherType。</li></ul></li><li><strong>網路層</strong><ul><li>源 IP 地址、目標 IP 地址。</li><li>IP 協議類型、DiffServ 欄位。</li></ul></li><li><strong>傳輸層</strong><ul><li>TCP/UDP 源端口、目標端口。</li></ul></li></ol><h4 id="openflow-支援的動作" tabindex="-1"><a class="header-anchor" href="#openflow-支援的動作"><span>OpenFlow 支援的動作</span></a></h4><ol><li><strong>基本動作</strong><ul><li><strong>Forward</strong>：將封包轉發到指定的輸出端口。</li><li><strong>Drop</strong>：丟棄封包，不進行處理。</li><li><strong>Send to Controller</strong>：將封包發送至控制器進一步處理。</li></ul></li><li><strong>修改動作</strong><ul><li>修改封包標頭欄位，如更改源/目標 MAC 地址、IP 地址或 TTL。</li></ul></li><li><strong>多播和泛洪</strong><ul><li>將封包複製並發送到多個輸出端口。</li></ul></li><li><strong>封包緩存</strong><ul><li>將未匹配的封包暫存在交換機內部，等待控制器下發規則。</li></ul></li></ol><h4 id="openflow-的工作流程" tabindex="-1"><a class="header-anchor" href="#openflow-的工作流程"><span>OpenFlow 的工作流程</span></a></h4><ol><li><strong>封包進入交換機</strong>：封包進入 OpenFlow 交換機後，會檢查流表進行匹配。</li><li><strong>匹配流表條目</strong>：若匹配成功，執行對應的動作。若無匹配條目，則將封包發送至控制器（Packet-in），由控制器決定處理方式。</li><li><strong>控制器下發規則</strong>：控制器根據網路策略，向交換機下發新的流表條目。交換機更新流表後，可獨立處理後續類似封包。</li></ol><h4 id="openflow-的應用場景" tabindex="-1"><a class="header-anchor" href="#openflow-的應用場景"><span>OpenFlow 的應用場景</span></a></h4><table><thead><tr><th><strong>Device</strong></th><th><strong>Match</strong></th><th><strong>Action</strong></th></tr></thead><tbody><tr><td><strong>Router</strong></td><td>Longest destination IP prefix</td><td>Forward out a link</td></tr><tr><td><strong>Firewall</strong></td><td>IP address and TCP/UDP port numbers</td><td>Permit or deny</td></tr><tr><td><strong>Switch</strong></td><td>Destination MAC address</td><td>Forward or flood</td></tr><tr><td><strong>NAT</strong></td><td>IP address and port</td><td>Rewrite address and port</td></tr></tbody></table><h4 id="openflow-的優點" tabindex="-1"><a class="header-anchor" href="#openflow-的優點"><span>OpenFlow 的優點</span></a></h4><ul><li><strong>集中管理</strong>：通過控制器統一管理網路設備，簡化配置。</li><li><strong>靈活性</strong>：支持動態修改規則，快速響應網路需求變化。</li><li><strong>可編程性</strong>：提供對網路行為的細粒度控制，適應不同場景。</li></ul><hr><h3 id="middleboxes" tabindex="-1"><a class="header-anchor" href="#middleboxes"><span>Middleboxes</span></a></h3><ul><li><strong>定義</strong>：任何在源宿主機之間執行非標準路由功能的中間設備。 <ul><li>範例：NAT、防火牆、負載平衡器、緩存。</li></ul></li><li><strong>功能轉變</strong><ul><li>從專有硬體向<strong>白盒解決方案</strong>演進。</li><li><strong>NFV</strong>（網路功能虛擬化）允許可編程服務的部署。</li><li>SDN提供集中控制和配置管理。</li></ul></li><li><strong>應用領域</strong><ul><li>家庭網路：NAT。</li><li>企業網路：防火牆、IDS。</li><li>數據中心：負載平衡器、緩存。</li></ul></li></ul><h2 id="network-layer-control-plane" tabindex="-1"><a class="header-anchor" href="#network-layer-control-plane"><span>Network Layer: Control Plane</span></a></h2><p><strong>網路層控制平面 (Control Plane)</strong> 定義了如何決定封包從源主機到目的地主機的路徑。主要有兩種架構：</p><ul><li><strong>每路由器控制 (Per-Router Control)</strong>: 傳統方式，各路由器獨立運行路由算法。</li><li><strong>邏輯集中控制 (Logically Centralized Control)</strong>: 由軟體定義網路(SDN)集中控制路由。</li></ul><figure><img src="/blog/assets/54-ChGHd5Mz.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="routing-protocols" tabindex="-1"><a class="header-anchor" href="#routing-protocols"><span>Routing Protocols</span></a></h3><ul><li>路由協議的目的是尋找從源到目的地的良好路徑 (good paths)，依據成本、速度、擁塞等指標選擇最佳路徑。常見的路由算法類型： <ul><li><strong>全局信息 (Global Information)</strong>: 所有路由器共享拓撲信息（如鏈路狀態算法，Link State Routing）。</li><li><strong>分散信息 (Decentralized Information)</strong>: 路由器僅與鄰居交換信息（如距離向量算法，Distance Vector Routing）。</li></ul></li></ul><figure><img src="/blog/assets/55-dZqn9dso.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="link-state-routing-dijkstra-s-algorithm" tabindex="-1"><a class="header-anchor" href="#link-state-routing-dijkstra-s-algorithm"><span>Link State Routing: Dijkstra&#39;s Algorithm</span></a></h3><p>Dijkstra算法是一種基於鏈路狀態的路由算法，用於計算從單一源節點到其他所有節點的最短路徑。</p><ul><li>集中式算法：所有節點都擁有完整的網路拓撲和鏈路成本信息。</li><li>使用 <strong>鏈路狀態廣播</strong> 收集網路資訊。</li><li>每次迭代會找到一條確定的最短路徑。</li></ul><h4 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h4><ul><li>計算從來源 node 到所有其他 node 的最小成本路徑(least cost paths)，會給予所有的 node forwarding table。</li><li>iterative : 經過k個迴圈，可以得到到k個目的地的最小成本路徑。<br><img src="/blog/assets/56-B4jJyijE.png" alt="" loading="lazy"><br><img src="/blog/assets/57-CnGlKbMT.png" alt="" loading="lazy"><br><img src="/blog/assets/58-q1RWvp50.png" alt="" loading="lazy"></li></ul><h4 id="常見問題" tabindex="-1"><a class="header-anchor" href="#常見問題"><span>常見問題</span></a></h4><ul><li>算法複雜度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi>log</mi><mo>⁡</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Theta (|E|+|V|\log|V|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</li><li>每個 router 都需要 broadcast 自己的 link state 資訊給其他 n 個 router</li><li>路徑震盪 (Route Oscillations)：如果將流量擁塞設為link cost，則會發生震盪的情形。<br><img src="/blog/assets/59-D29pbUw7.png" alt="" loading="lazy"></li></ul><hr><h3 id="distance-vector-routing-bellman-ford-algorithm" tabindex="-1"><a class="header-anchor" href="#distance-vector-routing-bellman-ford-algorithm"><span>Distance Vector Routing: Bellman-Ford Algorithm</span></a></h3><p>Bellman-Ford演算法是一種基於動態規劃的路由算法，用於計算從單一源節點到其他所有節點的最短路徑。與Dijkstra&#39;s Algorithm不同，Bellman-Ford可以處理負權重的鏈路成本，但其收斂速度較慢。</p><h4 id="方法-1" tabindex="-1"><a class="header-anchor" href="#方法-1"><span>方法</span></a></h4><ul><li>每個節點會不時的傳遞自己 distance vector estimate 給鄰居。假設 x 節點收到鄰居傳的新 DV estimate，x 會藉由 B-F equation 去更新自己的 DV。</li><li>一直重複做(重複交換訊息、更改自己的DV)，直到節點算出真的對其他node的真正最小成本路徑。</li><li>節點會一直重複下面狀態：等待 local link cost 的改變或是鄰居傳來新的 DV。根據鄰居傳來的DV重新計算自己的DV。如果重新計算的DV有改變，則會通知並傳給鄰居。</li><li>節點間的狀態是不同步的。</li><li>node 只會在必要的時候(自己DV有更新的時候)通知自己的鄰居自己的改變。如果 node 沒有收到通知，就不會有動作(action taken)。<br><img src="/blog/assets/60-B6t2Cxv6.png" alt="" loading="lazy"><br><img src="/blog/assets/61-CHUMzO-I.png" alt="" loading="lazy"></li></ul><h4 id="常見問題-1" tabindex="-1"><a class="header-anchor" href="#常見問題-1"><span>常見問題</span></a></h4><ul><li>可能出現計數到無窮 (Count-to-Infinity) 問題。</li><li>傳播錯誤信息的風險較高。</li><li><strong>link cost change</strong>：當 cost 突然由大變小，是可以順利正常運作的，但由小變大時，可能會造成無限loop(分散式的問題)。EX：由於 Z 的DV 告訴 Y 只需 5 就能到 X，Y 就會更新自己的 DV (Y 到 X 走 Z，cost=6)，Z 會再由 Y 更改自己的 DV (Z到X改成7 )，…無限循環，count-to-infinity。<br><img src="/blog/assets/62-BO1ZipJz.png" alt="" loading="lazy"></li></ul><h3 id="comparison-of-ls-and-dv-algorithms" tabindex="-1"><a class="header-anchor" href="#comparison-of-ls-and-dv-algorithms"><span>Comparison of LS and DV algorithms</span></a></h3><table><thead><tr><th></th><th><strong>Link State (LS)</strong></th><th><strong>Distance Vector (DV)</strong></th></tr></thead><tbody><tr><td><strong>Complexity (複雜度)</strong></td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（ n 為路由器數量）</td><td>收斂時間因路由器和拓撲而異</td></tr><tr><td><strong>Speed of Convergence (收斂速度)</strong></td><td>可能會震盪，但最終一定會收斂</td><td>每個節點收斂時間不同，<br>可能出現無限循環與計數到無窮問題</td></tr><tr><td><strong>Robustness (穩健性)</strong></td><td>- 可能會廣播錯誤的鏈路成本<br>- 每個路由器只計算自己<br>的路由表</td><td>- 可能傳遞錯誤的最短路徑資訊<br>- 錯誤可能透過鄰居逐漸傳播</td></tr></tbody></table><hr><h3 id="scalable-routing" tabindex="-1"><a class="header-anchor" href="#scalable-routing"><span>Scalable Routing</span></a></h3><p>目前的路由研究通常過於理想化，假設所有路由器的地位和功能是相同的。然而在實際中，這並不成立。隨著網路規模的擴大，路由器數量激增，已經無法在每個路由器的路由表中儲存所有目的地的信息。</p><h4 id="解決方法-自治系統-autonomous-systems-as" tabindex="-1"><a class="header-anchor" href="#解決方法-自治系統-autonomous-systems-as"><span>解決方法：自治系統 (Autonomous Systems, AS)</span></a></h4><p>自治系統 (AS) 是指由單一實體（或少數幾個實體）管轄的一組 IP 網路和路由器，它們共享相同的路由策略。將路由器劃分到不同的 AS 中，有助於分散管理並提高路由效率。</p><h4 id="路由類型" tabindex="-1"><a class="header-anchor" href="#路由類型"><span>路由類型</span></a></h4><ol><li><strong>AS內部路由 (Intra-AS Routing)</strong>：發生在同一個 AS 內部的路由，稱為 <strong>Intra-Domain Routing</strong>。<br><strong>特性</strong>：AS 內的所有路由器必須運行相同的 <strong>Intra-Domain Protocol</strong>。而不同 AS 的路由器可以運行各自不同的 <strong>Intra-Domain Protocol</strong>。</li><li><strong>AS之間的路由 (Inter-AS Routing)</strong>：發生在不同 AS 之間的路由，稱為 <strong>Inter-Domain Routing</strong>。<br><strong>特性</strong>：Inter-Domain Routing 由 <strong>Gateway Routers</strong> 執行，Gateway Routers 位於各自 AS 的邊界，負責與其他 AS 的路由器連接。Gateway Routers 同時進行 <strong>Inter-Domain</strong> 和 <strong>Intra-Domain Routing</strong>，在 AS 間交換路由信息。</li></ol><h4 id="路由算法與轉發表的生成" tabindex="-1"><a class="header-anchor" href="#路由算法與轉發表的生成"><span><strong>路由算法與轉發表的生成</strong></span></a></h4><ol><li><strong>轉發表配置</strong>： <ul><li>轉發表由 <strong>Intra-AS Routing</strong> 和 <strong>Inter-AS Routing</strong> 演算法共同生成。</li><li><strong>Intra-AS Routing</strong>：決定 AS 內部目的地的路徑。</li><li><strong>Inter-AS Routing</strong>：與 Intra-AS Routing 協作，共同決定外部目的地的路徑。</li></ul></li><li><strong>分工明確</strong>： <ul><li>在 AS 內，路由信息由 Intra-Domain Protocol 處理。</li><li>在 AS 之間，路由信息由 Gateway Router 通過 Inter-Domain Protocol 傳遞。</li></ul></li></ol><hr><h3 id="intra-isp-routing-ospf" tabindex="-1"><a class="header-anchor" href="#intra-isp-routing-ospf"><span>Intra-ISP Routing: OSPF</span></a></h3><p>OSPF（Open Shortest Path First）是一種基於 Link-State 的路由協議，用於自治系統（AS）內部的路由。作為一種開放標準協議，它克服了傳統 RIP 協議的局限性，支持更快的收斂速度和更靈活的路徑選擇。</p><h4 id="ospf-的特性" tabindex="-1"><a class="header-anchor" href="#ospf-的特性"><span>OSPF 的特性</span></a></h4><ol><li><strong>基於鏈路狀態的運作機制</strong>： <ul><li>每個路由器維護整個自治系統的完整拓撲視圖。</li><li>使用 <strong>鏈路狀態廣播 (Link-State Advertisement, LSA)</strong> 傳播鏈路成本信息。</li><li>根據 <strong>Dijkstra&#39;s Algorithm</strong> 計算從本地到其他路由器的最短路徑。</li></ul></li><li><strong>多樣化的鏈路成本指標</strong>： <ul><li>OSPF 支持多種鏈路成本度量（如帶寬、延遲等），可以根據網路需求進行靈活配置。</li><li>運營商可以根據業務需求自定義路徑選擇的優化目標。</li></ul></li><li><strong>快速收斂</strong>： <ul><li>當拓撲或鏈路成本發生變化時，OSPF 能夠快速傳播並更新路由信息，保證網路的穩定性和可用性。</li></ul></li><li><strong>安全性</strong>： <ul><li>支持消息認證（Message Authentication），以防止惡意攻擊或錯誤的路由更新消息。</li></ul></li></ol><h4 id="ospf-的結構" tabindex="-1"><a class="header-anchor" href="#ospf-的結構"><span>OSPF 的結構</span></a></h4><ol><li><strong>兩層結構</strong>： <ul><li><strong>區域 (Area)</strong>： <ul><li>路由器被劃分為多個區域，每個區域只需要了解自身內部的拓撲。</li><li>區域內的鏈路狀態信息會被洪泛（flooding）給區域內所有路由器。</li></ul></li><li><strong>骨幹 (Backbone)</strong>： <ul><li>連接所有區域，負責區域之間的路由通信。</li><li>骨幹被編號為 <strong>Area 0</strong>，其他區域需要通過骨幹進行互通。<br><img src="/blog/assets/63-DZWaKEVo.png" alt="" loading="lazy"></li></ul></li></ul></li><li><strong>路由器角色</strong>： <ul><li><strong>內部路由器 (Internal Router)</strong>：僅處理區域內部的路由。</li><li><strong>區域邊界路由器 (Area Border Router, ABR)</strong>：連接區域與骨幹，匯總區域內的路由信息並向骨幹廣播。</li><li><strong>骨幹路由器 (Backbone Router)</strong>：位於骨幹內，負責骨幹路由。</li><li><strong>邊界路由器 (Boundary Router)</strong>：連接其他自治系統（AS），負責交換外部路由信息。</li></ul></li></ol><h4 id="ospf-的運作過程" tabindex="-1"><a class="header-anchor" href="#ospf-的運作過程"><span>OSPF 的運作過程</span></a></h4><ol><li><strong>鏈路狀態廣播</strong>： <ul><li>當路由器啟動或拓撲發生變化時，會生成 <strong>LSA (Link-State Advertisement)</strong>，描述自身鏈路信息（如連接的鄰居及其成本）。</li><li>LSA 被洪泛至區域內所有路由器，使每個路由器都擁有相同的區域內拓撲信息。</li></ul></li><li><strong>構建鏈路狀態數據庫 (Link-State Database, LSDB)</strong>：路由器根據收到的 LSA 構建拓撲數據庫，記錄整個區域的網路拓撲。</li><li><strong>最短路徑計算</strong>： <ul><li>使用 <strong>Dijkstra&#39;s Algorithm</strong> 計算從自己到其他路由器的最短路徑。</li><li>生成轉發表（Forwarding Table），指導數據包的路徑選擇。</li></ul></li><li><strong>區域之間的路由</strong>： <ul><li>區域內的路由通過內部路由器和 ABR 進行處理。</li><li>區域間的路由由骨幹處理，ABR 將區域內路由信息摘要發送至骨幹。</li></ul></li></ol><hr><h3 id="inter-as-routing-bgp" tabindex="-1"><a class="header-anchor" href="#inter-as-routing-bgp"><span>Inter-AS Routing : BGP</span></a></h3><p>BGP（Border Gateway Protocol）是目前互聯網上使用的主要 <strong>Inter-AS Routing Protocol</strong>，被譽為「支撐整個互聯網的膠水」。它的主要功能是實現自治系統（AS）之間的路由，確保不同網路能夠互通。</p><h4 id="bgp-的運作方式" tabindex="-1"><a class="header-anchor" href="#bgp-的運作方式"><span>BGP 的運作方式</span></a></h4><ol><li><strong>eBGP（External BGP）</strong>：發生在不同自治系統（AS）之間。AS 的 Gateway Router 使用 eBGP 與鄰近 AS 的 Gateway Router 交換路由信息。</li><li><strong>iBGP（Internal BGP）</strong>：發生在同一自治系統內部。通過 iBGP，AS 內部的所有路由器都能共享從 eBGP 獲得的外部路由信息。</li><li><strong>BGP 消息類型</strong>： <ul><li><strong>OPEN</strong>：建立 BGP 對等會話並進行驗證。</li><li><strong>UPDATE</strong>：廣告新的路徑或撤回舊的路徑。</li><li><strong>KEEPALIVE</strong>：保持 BGP 對等會話的活動狀態。</li><li><strong>NOTIFICATION</strong>：報告錯誤或關閉會話。</li></ul></li></ol><figure><img src="/blog/assets/64-pSF3Y6Uk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="bgp-的功能" tabindex="-1"><a class="header-anchor" href="#bgp-的功能"><span>BGP 的功能</span></a></h4><ol><li><strong>路徑廣告（BGP path advertisement）</strong>：BGP 允許一個 AS 向鄰近的 AS 廣告其網路的可達性。當一個 AS 接收到鄰居的路由信息後，可以根據自身的策略決定是否採納並廣播給其他鄰居。<br><img src="/blog/assets/65-Dq1aZ6k9.png" alt="" loading="lazy"></li><li><strong>路由選擇與分發</strong>：內部 BGP（iBGP）負責在同一 AS 內傳播路由，外部 BGP（eBGP）負責在不同 AS 之間傳遞路由。BGP 會選擇到達某目的地的最佳路徑，並根據 AS 的政策傳播這些路由信息。</li></ol><h4 id="bgp-路由選擇過程" tabindex="-1"><a class="header-anchor" href="#bgp-路由選擇過程"><span>BGP 路由選擇過程</span></a></h4><ol><li><strong>Local Preference (本地偏好值)</strong>：管理員設定的策略，用於優先選擇特定的路徑。值越高，優先級越高。</li><li><strong>AS-PATH 長度</strong>：AS-PATH 是一個屬性，記錄路由信息所經歷的 AS 序列。BGP 會選擇 AS-PATH 路徑較短的路由。</li><li><strong>NEXT-HOP 距離</strong>：選擇距離本地最近的下一跳（NEXT-HOP）路由器，這被稱為 <strong>Hot Potato Routing</strong>。<br><img src="/blog/assets/66-BUBjcgU2.png" alt="" loading="lazy"></li><li><strong>其他條件</strong>：如路由的起源類型（IGP 路由優先於 eBGP 路由）等。</li></ol><h4 id="bgp-的屬性" tabindex="-1"><a class="header-anchor" href="#bgp-的屬性"><span>BGP 的屬性</span></a></h4><ol><li><strong>AS-PATH</strong>：紀錄廣告此路由信息所經過的 AS 序列。並防止路由環路，並用於選擇最短路徑。</li><li><strong>NEXT-HOP</strong>：指定到達目標網路的下一跳路由器。</li><li><strong>LOCAL_PREF（本地優先級）</strong>：用於 AS 內部，幫助選擇出口路由器。</li><li><strong>MED (Multi-Exit Discriminator)</strong>：用於告訴鄰近 AS，當多條路徑可用時，選擇哪條作為首選。</li></ol><p><img src="/blog/assets/67-CD4mH1HK.png" alt="" loading="lazy"><br> router可能收到同一個prefix但是是透過不同的路徑傳輸，如1c收到3a與2a送的eBGP訊息，皆是告訴1c有目的地x。</p><ul><li>根據policy, 1c會選擇 path AS3,x，然後藉由iBGP廣播這個path給AS1裡的router。</li><li>可以import policy去決定要走哪條路徑或是要拒絕還是接收廣播訊息。</li><li>可用policy來決定要不要廣播路徑與目的地給其他gateway router，可能是取決於其他AS有沒有付費。</li></ul><h4 id="bgp-與-ospf-的區別" tabindex="-1"><a class="header-anchor" href="#bgp-與-ospf-的區別"><span>BGP 與 OSPF 的區別</span></a></h4><table><thead><tr><th></th><th><strong>BGP</strong></th><th><strong>OSPF</strong></th></tr></thead><tbody><tr><td><strong>應用範圍</strong></td><td>跨自治系統（Inter-AS Routing）</td><td>自治系統內部（Intra-AS Routing）</td></tr><tr><td><strong>路由策略</strong></td><td>基於策略（Policy-Based）</td><td>基於性能（Performance-Based）</td></tr><tr><td><strong>拓撲結構</strong></td><td>分佈式，無全局拓撲視圖</td><td>全局拓撲視圖，基於鏈路狀態信息</td></tr><tr><td><strong>協議類型</strong></td><td>路徑向量協議（Path-Vector Protocol）</td><td>鏈路狀態協議（Link-State Protocol）</td></tr><tr><td><strong>收斂速度</strong></td><td>慢，依賴 AS 間的信息傳播</td><td>快，基於洪泛和 Dijkstra 算法</td></tr></tbody></table><hr><h3 id="sdn-control-plane" tabindex="-1"><a class="header-anchor" href="#sdn-control-plane"><span>SDN Control Plane</span></a></h3><p><strong>SDN (Software-Defined Networking)</strong> 是一種將網路控制平面和數據平面分離的網路架構。通過將控制邏輯集中在中央控制器中，易於管理(如:流量管理、特別的傳送路徑)與更改，且使用上比較彈性，提高網路的可編程性和靈活性。提供了一種與傳統每路由器控制平面不同的邏輯集中控制方法。</p><h4 id="sdn-控制平面的特性" tabindex="-1"><a class="header-anchor" href="#sdn-控制平面的特性"><span>SDN 控制平面的特性</span></a></h4><ol><li><strong>集中式控制</strong>： <ul><li>控制器充當網路的「大腦」，擁有網路的全局視圖。</li><li>控制器負責計算轉發表，並將其下發到各數據平面設備（如交換機）。</li></ul></li><li><strong>控制平面和數據平面的分離</strong>： <ul><li><strong>控制平面</strong>：負責路由計算和策略控制。</li><li><strong>數據平面</strong>：負責執行控制平面下發的轉發規則。</li></ul></li><li><strong>開放的標準接口</strong>： <ul><li>使用標準的南向 API（如 OpenFlow）與數據平面設備通信。</li><li>使用北向 API 與應用程序交互，允許開發第三方應用。</li></ul></li></ol><h4 id="sdn-的架構" tabindex="-1"><a class="header-anchor" href="#sdn-的架構"><span>SDN 的架構</span></a></h4><ol><li><strong>Data-Plane Switches</strong></li></ol><ul><li>快速簡單，做forwarding的硬體</li><li>會被安裝controller已計算好的flow(forwarding) table</li><li>會有table-based switch control的API(如:OpenFlow)</li><li>會有跟controller溝通的protocol(如:OpenFlow)</li></ul><ol start="2"><li><strong>SDN Controller (network OS)</strong></li></ol><ul><li>保留網路狀態、switch的資訊(分散式的database)</li><li>藉由northbound API去與上層的network-control app作互動</li><li>藉由southbound API去與下層的network switch作互動</li><li>用分散式系統，表現出好的性能、延展性、容錯性</li></ul><ol start="3"><li><strong>Network-Control Apps</strong></li></ol><ul><li>control的腦袋</li><li>利用control function去使用SDN conrtoller 提供的 lower-level service 跟 API</li><li>未綁定的(unbundled)，可以透過第三方去提供，可以自己去安裝或是更新想用的app</li></ul><figure><img src="/blog/assets/68-gy1UTSmu.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="sdn-與傳統網路的比較" tabindex="-1"><a class="header-anchor" href="#sdn-與傳統網路的比較"><span>SDN 與傳統網路的比較</span></a></h4><table><thead><tr><th><strong>指標</strong></th><th><strong>SDN</strong></th><th><strong>傳統網路</strong></th></tr></thead><tbody><tr><td><strong>控制方式</strong></td><td>集中控制（中央控制器）</td><td>分散式控制（每路由器獨立運算）</td></tr><tr><td><strong>靈活性</strong></td><td>高，可自定義網路行為</td><td>低，功能受限於設備廠商設計</td></tr><tr><td><strong>可見性</strong></td><td>全局網路視圖</td><td>僅有局部視圖</td></tr><tr><td><strong>擴展性</strong></td><td>易於新增功能，適應新技術</td><td>受硬體限制，難以新增功能</td></tr></tbody></table><hr><h3 id="openflow-protocol" tabindex="-1"><a class="header-anchor" href="#openflow-protocol"><span>OpenFlow protocol</span></a></h3><p>OpenFlow 是 SDN（Software-Defined Networking）的核心協議之一，用於控制平面和數據平面之間的通信，利用TCP來交換訊息。它允許 controller 向 switch 下發 flow table，並監控交換機的狀態。通過定義標準化 protocol，OpenFlow 實現了網路設備的統一控制與編程。</p><p>與Openflow API不同，Openflow API是用來標明generalized forwarding action</p><h4 id="openflow-的核心功能" tabindex="-1"><a class="header-anchor" href="#openflow-的核心功能"><span>OpenFlow 的核心功能</span></a></h4><ol><li><strong>流量控制</strong>：控制器可以動態定義數據平面設備的轉發行為，基於流量特徵（如 IP 地址、協議類型等）設置規則。</li><li><strong>流表管理</strong>：支援流表的添加、刪除和更新。流表包含匹配條件、執行動作（如轉發、丟棄）和計數器。</li><li><strong>設備監控</strong>：控制器可通過 OpenFlow 獲取交換機的狀態信息，包括流量統計和端口狀態。</li></ol><h4 id="openflow-的架構" tabindex="-1"><a class="header-anchor" href="#openflow-的架構"><span><strong>OpenFlow 的架構</strong></span></a></h4><ol><li><strong>控制器</strong>： <ul><li>集中化的網路控制節點，負責下發流表並管理網路狀態。</li></ul></li><li><strong>數據平面設備（OpenFlow Switch）</strong>： <ul><li>包含以下組件： <ul><li><strong>流表（Flow Table）</strong>：存儲匹配條件和對應的操作。</li><li><strong>Secure Channel</strong>：與控制器之間的通信通道。</li><li><strong>OpenFlow 協議支持</strong>：實現與控制器的消息交換。</li></ul></li></ul></li></ol><h4 id="openflow-的消息類型" tabindex="-1"><a class="header-anchor" href="#openflow-的消息類型"><span>OpenFlow 的消息類型</span></a></h4><ol><li><strong>Controller-to-Switch Messages (控制器到交換機消息)</strong><br> 控制器發送消息以查詢設備信息或修改流表：</li></ol><ul><li><strong>Features</strong>：查詢交換機的功能特性。</li><li><strong>Configure</strong>：設置交換機的參數。</li><li><strong>Modify-State</strong>：添加、刪除或修改流表條目。</li><li><strong>Packet-Out</strong>：將特定數據包發送到指定端口。</li></ul><ol start="2"><li><strong>Asynchronous Messages (非同步消息)</strong><br> 交換機主動向控制器發送的消息，用於通知異常或數據包處理：</li></ol><ul><li><strong>Packet-In</strong>：將無匹配條目的數據包轉發給控制器。</li><li><strong>Flow-Removed</strong>：通知控制器流表條目被刪除。</li><li><strong>Port Status</strong>：告知控制器端口狀態的變更（如端口啟用或故障）。</li></ul><ol start="3"><li><strong>Symmetric Messages (對稱消息)</strong><br> 控制器和交換機之間相互通信的消息，用於維持連接：</li></ol><ul><li><strong>Hello</strong>：初始化並建立控制器與交換機之間的通信。</li><li><strong>Echo Request/Reply</strong>：檢查連接的存活狀態。</li></ul><h4 id="openflow-流表" tabindex="-1"><a class="header-anchor" href="#openflow-流表"><span><strong>OpenFlow 流表</strong></span></a></h4><ol><li><p><strong>流表條目 (Flow Entry)</strong>：</p><ul><li>每條流表條目包括以下部分： <ul><li><strong>匹配字段 (Match Fields)</strong>：描述數據包的特徵，例如源/目標 IP 地址、協議類型等。</li><li><strong>優先級 (Priority)</strong>：決定條目的匹配順序，數值越高優先級越高。</li><li><strong>動作 (Actions)</strong>：執行的操作，如轉發、丟棄或修改數據包。</li><li><strong>計數器 (Counters)</strong>：記錄流量數據，例如匹配數據包的數量和字節數。</li><li><strong>超時 (Timeouts)</strong>：條目的生存時間，包括硬超時和閒置超時。</li></ul></li></ul></li><li><p><strong>處理邏輯</strong>：</p><ul><li>當數據包進入交換機時，根據流表條目匹配字段進行查找： <ul><li>若匹配到條目，執行對應動作。</li><li>若未匹配到條目，則執行預設行為（通常是將數據包發送到控制器）。</li></ul></li></ul></li></ol><h4 id="openflow-的工作流程-1" tabindex="-1"><a class="header-anchor" href="#openflow-的工作流程-1"><span>OpenFlow 的工作流程</span></a></h4><ol><li>S1, 遇到狀況會用OpenFlow status訊息通知controller</li><li>SDN controller收到訊息後，會更新link-status資訊</li><li>當link status改變時，Dijkstra&#39;s路由演算法會被呼叫</li><li>Dijkstra&#39;s路由演算法會存取controller裡網路圖與state資訊等資料，接著計算新的路由</li><li>link state routing app會再與SDN contoller裡的flow table做互動，計算新的flow table</li><li>controller再利用OpenFlow去安裝新的table到switch上</li></ol><figure><img src="/blog/assets/69-BSI8LKPv.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="openflow-的優勢" tabindex="-1"><a class="header-anchor" href="#openflow-的優勢"><span>OpenFlow 的優勢</span></a></h4><ol><li><strong>集中化控制</strong>：控制器擁有全局網路視圖，便於進行統一管理。</li><li><strong>靈活性</strong>：通過控制器動態修改流表規則，可適應快速變化的網路需求。</li><li><strong>標準化接口</strong>：支援多廠商設備互通，降低運營商對專有硬體的依賴。</li></ol><h4 id="sdn的挑戰" tabindex="-1"><a class="header-anchor" href="#sdn的挑戰"><span>SDN的挑戰</span></a></h4><p>control plane是非常可靠、有延展性的分布系統<br> 滿足即時、可靠、安全<br> 延展性:可以控制超過一個AS<br> 在5G時代非常重要</p><hr><h3 id="internet-control-message-protocol-icmp" tabindex="-1"><a class="header-anchor" href="#internet-control-message-protocol-icmp"><span>Internet Control Message Protocol (ICMP)</span></a></h3><p><strong>ICMP</strong> 是一種用於網路設備之間（如主機和路由器）傳遞網路資訊的協議，主要提供錯誤報告和診斷功能。它不是用於傳輸應用數據，而是協助 IP 協議在網路層執行錯誤處理與通信控制。所有 ICMP message 都嵌套在 IP datagram 中進行傳遞。</p><h4 id="icmp-的主要功能" tabindex="-1"><a class="header-anchor" href="#icmp-的主要功能"><span>ICMP 的主要功能</span></a></h4><ol><li><strong>錯誤回報 (Error Reporting)</strong>：向源主機通知封包傳輸過程中遇到的問題 <ul><li>無法到達的目標主機 (Host Unreachable)</li><li>網路不可達 (Network Unreachable)</li><li>端口不可達 (Port Unreachable)</li><li>協議不可用 (Protocol Unreachable)</li></ul></li><li><strong>請求與回應 (Request/Reply)</strong>：ICMP 提供請求/回應機制，例如被廣泛使用的 <strong>Ping 工具</strong>。</li></ol><h4 id="icmp-的應用" tabindex="-1"><a class="header-anchor" href="#icmp-的應用"><span>ICMP 的應用</span></a></h4><p><strong>1. Ping</strong>：<strong>Ping</strong> 是一種用於測試數據包能否通過 IP 協定到達目標主機的工具。</p><p>工作原理：</p><ul><li>向目標主機發送一個 <strong>ICMP Echo Request</strong> 封包。</li><li>目標主機若接收到該封包，則回傳一個 <strong>ICMP Echo Reply</strong>。</li><li>通過記錄成功回應次數和延遲時間（RTT, Round-Trip Time），可以估算： <ul><li><strong>丟包率 (Packet Loss Rate)</strong>：測試網路可靠性。</li><li><strong>往返延遲 (Round-Trip Delay Time)</strong>：測試網路時延。</li></ul></li></ul><p><strong>2. Traceroute</strong>：<strong>Traceroute</strong> 是一種用於跟蹤數據包路徑的工具，利用 ICMP 訊息來獲取數據包經過的路由器地址和延遲時間。</p><p>工作原理：</p><ul><li>來源端向目的地發送一個 UDP 資料段，並逐步增加 ICMP 資料包中的 <strong>TTL（Time-To-Live）</strong>。 <ol><li>第一次發送時，TTL 設為 1，封包到達第一個路由器後 TTL 減為 0。 <ul><li>該路由器丟棄封包並回傳 <strong>ICMP &quot;TTL expired&quot;</strong> 訊息。</li></ul></li><li>第二次發送時，TTL 設為 2，封包可到達第二個路由器，依此類推。</li><li>持續增加 TTL，直到數據包成功到達目的地，或者無法找到目的地時停止。</li></ol></li><li>來源端根據返回的 <strong>ICMP 訊息</strong> 獲取：路由器的 IP 地址與名稱，和各路由器的往返延遲時間（RTT）。</li><li><strong>用途</strong>：分析網路連通性，確定數據包的路徑和經過的路由器。</li></ul><hr><h3 id="network-management-and-configuration" tabindex="-1"><a class="header-anchor" href="#network-management-and-configuration"><span>Network Management and Configuration</span></a></h3><p>網路管理與配置是保障網路正常運行、性能優化以及故障排除的重要組成部分。它涵蓋監控、配置和管理網路設備（如路由器、交換機和伺服器），確保網路的高效性和安全性。</p><figure><img src="/blog/assets/70-BuxC7dqh.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="核心功能" tabindex="-1"><a class="header-anchor" href="#核心功能"><span>核心功能</span></a></h4><ol><li><p><strong>監控 (Monitoring)</strong>：</p><ul><li>持續追蹤網路設備的運行狀態、性能數據（如流量、延遲、丟包率）。</li><li>生成警報以提示異常（如設備故障、流量過高或連接中斷）。</li></ul></li><li><p><strong>配置 (Configuration)</strong>：</p><ul><li>設置和管理設備的參數（如 IP 地址、路由表、訪問控制列表）。</li><li>支援遠端批量配置，減少人工操作。</li></ul></li><li><p><strong>故障排除 (Troubleshooting)</strong>：</p><ul><li>掃描和診斷網路問題，快速定位故障來源。</li><li>提供工具（如 Ping、Traceroute）進行實時測試。</li></ul></li><li><p><strong>安全管理 (Security Management)</strong>：</p><ul><li>檢測和防禦網路攻擊。</li><li>實施訪問控制和資料加密。</li></ul></li></ol><h4 id="網路管理協議" tabindex="-1"><a class="header-anchor" href="#網路管理協議"><span>網路管理協議</span></a></h4><p><strong>1. SNMP (Simple Network Management Protocol)</strong></p><p>SNMP 是一種輕量級協議，用於監控和管理網路設備。使用一個分層結構的數據庫，稱為 <strong>MIB (Management Information Base)</strong>，來存儲設備狀態和配置信息。</p><ul><li><strong>核心功能</strong>： <ul><li><strong>獲取信息</strong>：管理器向設備請求信息（如設備狀態或流量數據）。</li><li><strong>設置參數</strong>：更改設備的配置（如啟用或禁用端口）。</li><li><strong>發送陷阱 (Trap)</strong>：設備主動發送警報信息給管理器，通知異常。</li></ul></li><li><strong>消息類型</strong>： <ul><li><strong>GetRequest</strong>: 請求設備的狀態數據。</li><li><strong>SetRequest</strong>: 修改設備的配置。</li><li><strong>Trap</strong>: 設備主動報告事件。</li></ul></li><li><strong>優勢</strong>： <ul><li>協議簡單，部署成本低。</li><li>支援多廠商設備的互操作性。</li></ul></li><li><strong>局限性</strong>： <ul><li>安全性較弱（SNMP v1 和 v2c 中的明文社群字串易被攔截）。</li><li>僅適用於較小型或簡單網路。</li></ul></li></ul><p><strong>2. NETCONF/YANG</strong></p><ul><li><strong>NETCONF</strong>：<strong>NETCONF (Network Configuration Protocol)</strong> 是一種基於 XML 的網路管理協議，專注於配置和狀態管理。 <ol><li><strong>配置管理</strong>：支援檢索、編輯和鎖定配置數據，確保網路參數的同步性。</li><li><strong>狀態監控</strong>：獲取設備的運行狀態數據（如性能指標）。</li><li><strong>數據驗證</strong>：配置變更前自動進行語法和一致性檢查。</li><li><strong>事務控制</strong>：支援原子性操作，配置變更要么全部成功，要么回滾至原始狀態。</li></ol></li><li><strong>YANG</strong>：<strong>YANG</strong> 是一種數據建模語言，與 NETCONF 配合使用，用於定義網路配置數據的結構和約束。 <ol><li>定義 NETCONF 配置數據的結構。</li><li>使用層次化模型描述數據（如網路拓撲）。</li><li>提供語法約束，保證配置數據的正確性。</li></ol></li><li><strong>優勢</strong>： <ul><li>高安全性，支持加密傳輸（基於 SSH）。</li><li>適合大規模網路，支援複雜配置和批量操作。</li></ul></li><li><strong>局限性</strong>： <ul><li>學習曲線較高，需要掌握 XML 和 YANG 語法。</li><li>部署成本較高，適合企業級或運營商網路。</li></ul></li></ul><h4 id="snmp-與-netconf-的比較" tabindex="-1"><a class="header-anchor" href="#snmp-與-netconf-的比較"><span>SNMP 與 NETCONF 的比較</span></a></h4><table><thead><tr><th><strong>指標</strong></th><th><strong>SNMP</strong></th><th><strong>NETCONF/YANG</strong></th></tr></thead><tbody><tr><td><strong>數據交換格式</strong></td><td>原始數據或明文社群字串</td><td>基於 XML，支持結構化數據</td></tr><tr><td><strong>功能範圍</strong></td><td>主要用於監控和簡單配置</td><td>支援複雜配置、事務控制和數據驗證</td></tr><tr><td><strong>安全性</strong></td><td>安全性較低（SNMPv1、v2c）</td><td>安全性高（基於 SSH 加密）</td></tr><tr><td><strong>適用場景</strong></td><td>小型或簡單網路</td><td>大型企業網路或運營商網路</td></tr></tbody></table><hr><h1 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h1><ul><li><a href="https://gaia.cs.umass.edu/kurose_ross/index.php" target="_blank" rel="noopener noreferrer">Computer Networking: A Top-Down Approach 8th edition</a></li><li><a href="https://hackmd.io/@0xff07/network/https%3A%2F%2Fhackmd.io%2F%400xff07%2FByADDQ57Y" target="_blank" rel="noopener noreferrer">110-1 計算機網路 (清大開放式課程)</a></li><li><a href="https://www.kaspersky.com.tw/resource-center/definitions/cookies" target="_blank" rel="noopener noreferrer">cookies</a></li><li><a href="https://oldmo860617.medium.com/%E6%A5%B5%E9%99%90%E5%8A%A0%E9%80%9F-web-%E9%96%8B%E7%99%BC%E8%80%85%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-cache-%E5%A4%A7%E8%A3%9C%E5%B8%96-3c7a9c4241de" target="_blank" rel="noopener noreferrer">極限加速！Web 開發者不能不知道的 Cache 大補帖！</a></li><li><a href="https://linux.vbird.org/linux_server/redhat9/0420squid.php" target="_blank" rel="noopener noreferrer">Proxy Server</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10225751" target="_blank" rel="noopener noreferrer">網路傳輸的優化 - HTTP 1.0 至 HTTP 3.0</a></li><li><a href="https://hackmd.io/@UULi" target="_blank" rel="noopener noreferrer">計算機網路筆記</a></li><li><a href="https://nordvpn.com/zh-tw/blog/ziwanglu-zhezhao/" target="_blank" rel="noopener noreferrer">子網路遮罩是什麼？</a></li></ul></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/albertwang1104/blog/edit/main/src/posts/CSIE/computer_internet.md" aria-label="Edit this page on GitHub" rel="noopener noreferrer" target="_blank" iconsizing="both"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last update: </span><span class="vp-meta-info" data-allow-mismatch="text">2/28/2025, 1:58:58 PM</span></div><div class="contributors"><span class="vp-meta-label">Contributors: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 80242923+albertwang1104@users.noreply.github.com">albertwang1104</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-DZYAv3Hw.js" defer></script>
  </body>
</html>
