import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,h as r,o as n}from"./app-BEwo00Y4.js";const i={};function o(p,e){return n(),a("div",null,e[0]||(e[0]=[r('<h2 id="representation-of-a-graph" tabindex="-1"><a class="header-anchor" href="#representation-of-a-graph"><span>Representation of a Graph</span></a></h2><h3 id="adjacency-matrix" tabindex="-1"><a class="header-anchor" href="#adjacency-matrix"><span>Adjacency Matrix</span></a></h3><p><strong>Direct Graph</strong><br> 求頂點i的In/Out-Degree？In-Degree將第i列加總；Out-Degree將第i行加總</p><h2 id="minimum-spanning-tree" tabindex="-1"><a class="header-anchor" href="#minimum-spanning-tree"><span>Minimum Spanning Tree</span></a></h2><h3 id="kruskal-s-algorithm" tabindex="-1"><a class="header-anchor" href="#kruskal-s-algorithm"><span>Kruskal&#39;s algorithm</span></a></h3><p>通過不斷選擇當前情況下的最優解，也就是權重最小的邊，並使用&quot;不形成循環&quot;的條件來確保最終生成樹是一棵樹，並且包含所有節點。</p><p>Kruskal演算法的主要步驟如下：</p><ol><li>初始化：首先，將所有的邊按照權重升序排序，同時初始化一個空的最小生成樹。</li><li>依次選擇最小權重的邊：從排序後的邊中選擇權重最小的邊，然後將其添加到最小生成樹中。</li><li>檢查是否形成循環：在添加新邊之後，檢查是否形成了循環。如果形成循環，則捨棄該邊，以確保生成樹的連通性，然後繼續選擇下一個最小權重的邊。</li><li>重複步驟2和步驟3：持續執行步驟2和步驟3，直到最小生成樹包含所有節點或所有邊已經被考慮完。</li></ol><p>Kruskal演算法是一種貪心算法，因為它優先選擇當前情況下的最優解，而不關心全局最優解。演算法的時間複雜度通常為O(E log E)，其中E是邊的數目。</p><h3 id="sollin-s-algorithm" tabindex="-1"><a class="header-anchor" href="#sollin-s-algorithm"><span>Sollin&#39;s algorithm</span></a></h3><p>Steps:</p><ol><li>將各頂點視為獨立的一棵樹</li><li>就每棵樹挑出成本最小的邊，並加入此樹</li><li>刪除重複挑出的邊，只保留一份</li><li>重複2~3直到只剩一棵樹，或是無邊可挑</li></ol><blockquote><p>若圖的邊權重有重複，則最小生成樹不唯一；若權重全不同，則此圖有唯一的最小生成樹。（cut property）</p></blockquote><ul><li><a href="https://garychang.gitbook.io/data-structure/4-graph" target="_blank" rel="noopener noreferrer">Graph</a></li><li><a href="https://medium.com/@ralph-tech/%E6%BC%94%E7%AE%97%E6%B3%95%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A8%B9-minimum-spanning-tree-mst-26c9482419a7" target="_blank" rel="noopener noreferrer">最小生成樹-minimum-spanning-tree-mst</a></li></ul>',14)]))}const h=t(i,[["render",o],["__file","graph.html.vue"]]),m=JSON.parse(`{"path":"/posts/Data%20Structure%20and%20Algorithm/graph.html","title":"Graph","lang":"en-US","frontmatter":{"title":"Graph","order":2,"date":"2025-11-30T00:00:00.000Z","category":["DSA"],"tag":["Study Note"],"description":"Representation of a Graph Adjacency Matrix Direct Graph 求頂點i的In/Out-Degree？In-Degree將第i列加總；Out-Degree將第i行加總 Minimum Spanning Tree Kruskal's algorithm 通過不斷選擇當前情況下的最優解，也就是權重最小的邊，並...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/Data%20Structure%20and%20Algorithm/graph.html"}],["meta",{"property":"og:site_name","content":"Yuan Heng's Blog"}],["meta",{"property":"og:title","content":"Graph"}],["meta",{"property":"og:description","content":"Representation of a Graph Adjacency Matrix Direct Graph 求頂點i的In/Out-Degree？In-Degree將第i列加總；Out-Degree將第i行加總 Minimum Spanning Tree Kruskal's algorithm 通過不斷選擇當前情況下的最優解，也就是權重最小的邊，並..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-12-13T05:54:09.000Z"}],["meta",{"property":"article:tag","content":"Study Note"}],["meta",{"property":"article:published_time","content":"2025-11-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-13T05:54:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Graph\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-13T05:54:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yuan Heng\\",\\"url\\":\\"https://albertwang1104.github.io/blog/\\"}]}"]]},"git":{"createdTime":1765605249000,"updatedTime":1765605249000,"contributors":[{"name":"albertwang1104","username":"albertwang1104","email":"80242923+albertwang1104@users.noreply.github.com","commits":1,"url":"https://github.com/albertwang1104"}]},"readingTime":{"minutes":1.64,"words":492},"filePathRelative":"posts/Data Structure and Algorithm/graph.md","localizedDate":"November 30, 2025","excerpt":"<h2>Representation of a Graph</h2>\\n<h3>Adjacency Matrix</h3>\\n<p><strong>Direct Graph</strong><br>\\n求頂點i的In/Out-Degree？In-Degree將第i列加總；Out-Degree將第i行加總</p>\\n<h2>Minimum Spanning Tree</h2>\\n<h3>Kruskal's algorithm</h3>\\n<p>通過不斷選擇當前情況下的最優解，也就是權重最小的邊，並使用\\"不形成循環\\"的條件來確保最終生成樹是一棵樹，並且包含所有節點。</p>\\n<p>Kruskal演算法的主要步驟如下：</p>","autoDesc":true}`);export{h as comp,m as data};
